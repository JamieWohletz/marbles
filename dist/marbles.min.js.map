{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marbles.min.js","webpack:///webpack/bootstrap 8bf625381812d56ad343","webpack:///./src/marbles.js","webpack:///./src/util.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","prototype","_util","Marbles","routingGraph","expandSegment","segment","data","replace","DYNAMIC_SEGMENT_REGEX","segmentKey","extractSegmentData","templateSegment","segmentWithData","dynamicSegments","match","RegExp","source","DIGIT_SEGMENT_REGEX","reduce","index","assign","emptyObject","segmentToRegex","regexed","findListNode","nodeId","list","next","chainData","upToNode","stop","isObject","graphNodeToListNode","graph","graphNode","deactivateGraphNode","force","immutableGraph","recDeactivate","target","current","g","curr","dependency","active","children","forEach","childId","cloneDeep","activateGraphNode","dfsActivate","searchId","currentId","dependencyMet","search","depMet","parents","keys","filter","key","indexOf","activated","parentId","retG","appendNode","node","head","clonedHead","last","parseHash","hashRoute","routeGraph","recParse","hash","rootId","visitedNodes","child","newG","matches","substrIndex","length","arrayHead","substr","newGraph","buildGraph","IMMUTABLE_GRAPH","listToHashRoute","str","graphToLinkedList","listHead","nextListNode","newHead","logGraph","lastGraph","peek","graphStack","JSON","stringify","push","graphToList","notifyObservers","obsObj","oldGraph","oldListHead","newListHead","missing","nxt","arr","routeId","obs","removed","observerArray","i","inserted","insertOrRemove","insert","dataToUse","isString","Array","win","location","arguments","undefined","window","observers","subscribe","subscriptions","matchingKeys","sub","noop","unsubscribe","route","event","handler","isFunction","matchingObservers","pull","remove","getData","step","originalHash","pop","history","replaceState","listener","bind","start","addEventListener","removeEventListener","default","create","any","parse","_len","args","_key","apply","array","values","map","val","results","concat","splice","returnArray","subArray","without","newArray","slice"],"mappings":"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","file":"marbles.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Marbles = function Marbles(routingGraph) {\n\t  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\t\n\t  _classCallCheck(this, Marbles);\n\t\n\t  var IMMUTABLE_GRAPH = routingGraph;\n\t  var DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n\t  var DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n\t  var observers = (0, _util.keys)(IMMUTABLE_GRAPH).reduce(function (obj, key) {\n\t    obj[key] = [];\n\t    return obj;\n\t  }, (0, _util.emptyObject)());\n\t  var graphStack = [];\n\t\n\t  // Private methods\n\t  function expandSegment(segment, data) {\n\t    return segment.replace(DYNAMIC_SEGMENT_REGEX, function (segmentKey) {\n\t      return data[segmentKey.replace(':', '')];\n\t    });\n\t  }\n\t\n\t  function extractSegmentData(templateSegment, segmentWithData) {\n\t    var dynamicSegments = templateSegment.match(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')) || [];\n\t    return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce(function (data, value, index) {\n\t      data[dynamicSegments[index].replace(':', '')] = value;\n\t      return (0, _util.assign)((0, _util.emptyObject)(), data);\n\t    }, (0, _util.emptyObject)());\n\t  }\n\t\n\t  function segmentToRegex(segment) {\n\t    // It just got weird\n\t    var regexed = segment.replace(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'), DIGIT_SEGMENT_REGEX.source);\n\t    return new RegExp(regexed);\n\t  }\n\t\n\t  function findListNode(nodeId, list) {\n\t    var next = list;\n\t    while (next) {\n\t      if (next.id === nodeId) {\n\t        return next;\n\t      }\n\t      next = next.next;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function chainData(list, upToNode) {\n\t    var data = (0, _util.emptyObject)();\n\t    var stop = (0, _util.isObject)(upToNode) ? upToNode : { data: {} };\n\t    var next = list;\n\t    while (next && next !== stop) {\n\t      (0, _util.assign)(data, next.data);\n\t      next = next.next;\n\t    }\n\t    return (0, _util.assign)(data, stop.data);\n\t  }\n\t\n\t  function graphNodeToListNode(id, graph) {\n\t    var graphNode = graph[id];\n\t    return (0, _util.assign)((0, _util.emptyObject)(), graphNode, {\n\t      id: id,\n\t      segment: expandSegment(graphNode.segment, graphNode.data),\n\t      next: null\n\t    });\n\t  }\n\t\n\t  function deactivateGraphNode(force, nodeId, immutableGraph) {\n\t    var graph = (0, _util.cloneDeep)(immutableGraph);\n\t    function recDeactivate(target, current, g) {\n\t      var curr = g[current];\n\t      if (target === current || curr.dependency === target || force) {\n\t        curr.active = false;\n\t        curr.data = (0, _util.emptyObject)();\n\t      }\n\t      curr.children.forEach(function (childId) {\n\t        return recDeactivate(target, childId, g);\n\t      });\n\t    }\n\t    recDeactivate(nodeId, nodeId, graph);\n\t    return graph;\n\t  }\n\t\n\t  function activateGraphNode(nodeId, data, immutableGraph) {\n\t    var graph = (0, _util.cloneDeep)(immutableGraph);\n\t    var parents = (0, _util.keys)(graph).filter(function (key) {\n\t      return graph[key].children.indexOf(nodeId) !== -1;\n\t    });\n\t    function dfsActivate(searchId, currentId, dependencyMet) {\n\t      var curr = graph[currentId];\n\t      var search = graph[searchId];\n\t      if (currentId === searchId && dependencyMet) {\n\t        search.active = true;\n\t        search.data = data;\n\t        return true;\n\t      } else if (currentId === searchId && !dependencyMet) {\n\t        return false;\n\t      }\n\t      return curr.children.reduce(function (depMet, childId) {\n\t        return dfsActivate(searchId, childId, depMet);\n\t      }, dependencyMet || currentId === search.dependency);\n\t    }\n\t\n\t    var activated = dfsActivate(nodeId, 'root', false);\n\t    if (activated) {\n\t      // deactivate immediate siblings\n\t      return parents.reduce(function (g, parentId) {\n\t        return g[parentId].children.filter(function (id) {\n\t          return id !== nodeId;\n\t        }).reduce(function (retG, childId) {\n\t          return deactivateGraphNode(true, childId, retG);\n\t        }, g);\n\t      }, graph);\n\t    }\n\t    return graph;\n\t  }\n\t\n\t  function appendNode(node, head) {\n\t    var clonedHead = (0, _util.cloneDeep)(head);\n\t    var next = clonedHead;\n\t    var last = void 0;\n\t    var dependencyMet = false;\n\t    while (next) {\n\t      dependencyMet = dependencyMet || next.id === node.dependency;\n\t      last = next;\n\t      next = next.next;\n\t    }\n\t    if (dependencyMet) {\n\t      last.next = (0, _util.cloneDeep)(node);\n\t    }\n\t    return clonedHead;\n\t  }\n\t\n\t  function parseHash(hashRoute, routeGraph) {\n\t    function recParse(hash, rootId, visitedNodes, graph) {\n\t      var root = graph[rootId];\n\t      return root.children.reduce(function (g, childId) {\n\t        var child = graph[childId];\n\t        var newG = g;\n\t        var matches = hash.match(segmentToRegex(child.segment)) || [];\n\t        var substrIndex = matches.index ? matches.index + matches[0].length : 0;\n\t        if (visitedNodes[childId]) {\n\t          return newG;\n\t        }\n\t        visitedNodes[childId] = true;\n\t        if (matches.length > 0 && (graph[child.dependency] || (0, _util.emptyObject)()).active) {\n\t          newG = activateGraphNode(childId, extractSegmentData(child.segment, (0, _util.arrayHead)(matches)), graph);\n\t        }\n\t        return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n\t      }, graph);\n\t    }\n\t    var newGraph = (0, _util.cloneDeep)(routeGraph);\n\t    return recParse(hashRoute, 'root', {}, newGraph);\n\t  }\n\t\n\t  function buildGraph(hash) {\n\t    return parseHash(hash, IMMUTABLE_GRAPH);\n\t  }\n\t\n\t  function listToHashRoute(head) {\n\t    var str = '#';\n\t    var next = head;\n\t    while (next) {\n\t      if (next.segment) {\n\t        str += next.segment + '/';\n\t      }\n\t      next = next.next;\n\t    }\n\t    return str;\n\t  }\n\t\n\t  function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n\t    var root = graph[rootId];\n\t    var nextListNode = graphNodeToListNode(rootId, graph);\n\t    var newHead = root.active ? appendNode(nextListNode, listHead) : (0, _util.cloneDeep)(listHead);\n\t\n\t    return root.children.reduce(function (head, childId) {\n\t      if (visitedNodes[childId]) {\n\t        return head;\n\t      }\n\t      visitedNodes[childId] = true;\n\t      return graphToLinkedList(graph, childId, head, visitedNodes);\n\t    }, newHead);\n\t  }\n\t\n\t  function logGraph(newGraph) {\n\t    var lastGraph = (0, _util.peek)(graphStack);\n\t    if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n\t      graphStack.push(newGraph);\n\t    }\n\t    return newGraph;\n\t  }\n\t\n\t  function graphToList(graph) {\n\t    if (!graph) {\n\t      return null;\n\t    }\n\t    return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), (0, _util.emptyObject)());\n\t  }\n\t\n\t  function notifyObservers(obsObj, oldGraph, newGraph) {\n\t    var oldListHead = graphToList(oldGraph);\n\t    var newListHead = graphToList(newGraph);\n\t    var missing = function () {\n\t      var nxt = oldListHead;\n\t      var arr = [];\n\t      while (nxt) {\n\t        if (!findListNode(nxt.id, newListHead)) {\n\t          arr.push(nxt.id);\n\t        }\n\t        nxt = nxt.next;\n\t      }\n\t      return arr;\n\t    }();\n\t    missing.forEach(function (routeId) {\n\t      obsObj[routeId].forEach(function (obs) {\n\t        obs.removed();\n\t      });\n\t    });\n\t    var next = newListHead;\n\t    while (next) {\n\t      var observerArray = obsObj[next.id];\n\t      for (var i = 0; i < observerArray.length; i++) {\n\t        observerArray[i].inserted(chainData(newListHead, next));\n\t      }\n\t      next = next.next;\n\t    }\n\t  }\n\t\n\t  function insertOrRemove(insert, routeId, data) {\n\t    var dataToUse = data;\n\t    if (!(0, _util.isString)(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n\t      return null;\n\t    }\n\t    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data instanceof Array) {\n\t      dataToUse = (0, _util.emptyObject)();\n\t    }\n\t    var graph = buildGraph(win.location.hash);\n\t    var newGraph = void 0;\n\t    if (insert) {\n\t      newGraph = activateGraphNode(routeId, dataToUse, graph);\n\t    } else {\n\t      newGraph = deactivateGraphNode(false, routeId, graph);\n\t    }\n\t    win.location.hash = listToHashRoute(graphToList(newGraph));\n\t    return this;\n\t  }\n\t  // End private methods\n\t\n\t  // Public methods\n\t  this.subscribe = function subscribe(subscriptions) {\n\t    if (!(0, _util.isObject)(subscriptions)) {\n\t      return false;\n\t    }\n\t    var matchingKeys = (0, _util.keys)(subscriptions).filter(function (key) {\n\t      return !!observers[key];\n\t    });\n\t    if (matchingKeys.length === 0) {\n\t      return false;\n\t    }\n\t    matchingKeys.forEach(function (key) {\n\t      var sub = subscriptions[key];\n\t      observers[key].push({\n\t        inserted: sub.inserted || _util.noop,\n\t        removed: sub.removed || _util.noop\n\t      });\n\t    });\n\t    return true;\n\t  };\n\t  this.unsubscribe = function unsubscribe(route, event, handler) {\n\t    if (!(0, _util.isString)(route) || !(0, _util.isString)(event) || !(0, _util.isFunction)(handler) || !observers[route]) {\n\t      return false;\n\t    }\n\t    var matchingObservers = observers[route].filter(function (obs) {\n\t      return obs[event] === handler;\n\t    });\n\t    return (0, _util.pull)(matchingObservers, observers[route]);\n\t  };\n\t  this.insert = function insert(routeId, data) {\n\t    return insertOrRemove.call(this, true, routeId, data);\n\t  };\n\t  this.remove = function remove(routeId) {\n\t    return insertOrRemove.call(this, false, routeId);\n\t  };\n\t  this.getData = function getData() {\n\t    return chainData(graphToList(buildGraph(win.location.hash)));\n\t  };\n\t  this.step = function step() {\n\t    var originalHash = win.location.hash;\n\t    var graph = buildGraph(originalHash);\n\t    notifyObservers(observers, graphStack.pop(), graph);\n\t    logGraph(graph);\n\t    win.history.replaceState((0, _util.emptyObject)(), '', listToHashRoute(graphToList(graph)));\n\t    return this;\n\t  };\n\t\n\t  var listener = this.step.bind(this);\n\t  this.start = function start() {\n\t    win.addEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  this.stop = function stop() {\n\t    win.removeEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  // End public methods\n\t};\n\t\n\texports.default = Marbles;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction emptyObject() {\n\t  return Object.create(null);\n\t}\n\t\n\tfunction isObject(any) {\n\t  return (typeof any === 'undefined' ? 'undefined' : _typeof(any)) === 'object' && any !== null && !(any instanceof Array);\n\t}\n\t\n\tfunction isString(any) {\n\t  return typeof any === 'string';\n\t}\n\t\n\tfunction isFunction(any) {\n\t  return typeof any === 'function';\n\t}\n\t\n\tfunction keys(obj) {\n\t  return Object.keys(obj);\n\t}\n\t\n\tfunction cloneDeep(obj) {\n\t  return JSON.parse(JSON.stringify(obj));\n\t}\n\t\n\tfunction assign() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return Object.assign.apply(this, args);\n\t}\n\t\n\tfunction arrayHead(array) {\n\t  if (typeof array === 'undefined' || !(array instanceof Array)) {\n\t    return undefined;\n\t  }\n\t  return array[0];\n\t}\n\t\n\tfunction pull(values, array) {\n\t  return values.map(function (val) {\n\t    var index = array.indexOf(val);\n\t    var results = [];\n\t    while (index !== -1) {\n\t      results = results.concat(array.splice(index, 1));\n\t      index = array.indexOf(val);\n\t    }\n\t    return results;\n\t  }).reduce(function (returnArray, subArray) {\n\t    return returnArray.concat(subArray);\n\t  }, []).reduce(function (returnArray, val) {\n\t    if (returnArray.indexOf(val) !== -1) {\n\t      return returnArray;\n\t    }\n\t    return returnArray.concat(val instanceof Array ? [val] : val);\n\t  }, []);\n\t}\n\t\n\tfunction without(values, array) {\n\t  var newArray = array.slice();\n\t  pull(values, newArray);\n\t  return newArray;\n\t}\n\t\n\tfunction peek(arr) {\n\t  if (!arr || !(arr instanceof Array)) {\n\t    return null;\n\t  }\n\t  return arr[arr.length - 1] || null;\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.emptyObject = emptyObject;\n\texports.isObject = isObject;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.noop = noop;\n\texports.keys = keys;\n\texports.peek = peek;\n\texports.cloneDeep = cloneDeep;\n\texports.assign = assign;\n\texports.arrayHead = arrayHead;\n\texports.pull = pull;\n\texports.without = without;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// marbles.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8bf625381812d56ad343","import {\n  pull,\n  isString,\n  isFunction,\n  emptyObject,\n  noop,\n  keys,\n  cloneDeep,\n  assign,\n  arrayHead,\n  isObject,\n  peek\n} from './util.js';\n\nexport default class Marbles {\n  constructor(routingGraph, win = window) {\n    const IMMUTABLE_GRAPH = routingGraph;\n    const DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n    const DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n    const observers = keys(IMMUTABLE_GRAPH).reduce((obj, key) => {\n      obj[key] = [];\n      return obj;\n    }, emptyObject());\n    const graphStack = [];\n\n    // Private methods\n    function expandSegment(segment, data) {\n      return segment.replace(\n        DYNAMIC_SEGMENT_REGEX,\n        segmentKey => data[segmentKey.replace(':', '')]\n      );\n    }\n\n    function extractSegmentData(templateSegment, segmentWithData) {\n      const dynamicSegments = templateSegment.match(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')\n      ) || [];\n      return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce((data, value, index) => {\n        data[dynamicSegments[index].replace(':', '')] = value;\n        return assign(emptyObject(), data);\n      },\n        emptyObject()\n      );\n    }\n\n    function segmentToRegex(segment) {\n      // It just got weird\n      const regexed = segment.replace(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'),\n        DIGIT_SEGMENT_REGEX.source\n      );\n      return new RegExp(regexed);\n    }\n\n    function findListNode(nodeId, list) {\n      let next = list;\n      while (next) {\n        if (next.id === nodeId) {\n          return next;\n        }\n        next = next.next;\n      }\n      return null;\n    }\n\n    function chainData(list, upToNode) {\n      const data = emptyObject();\n      const stop = isObject(upToNode) ? upToNode : { data: {} };\n      let next = list;\n      while (next && next !== stop) {\n        assign(data, next.data);\n        next = next.next;\n      }\n      return assign(data, stop.data);\n    }\n\n    function graphNodeToListNode(id, graph) {\n      const graphNode = graph[id];\n      return assign(emptyObject(), graphNode, {\n        id,\n        segment: expandSegment(graphNode.segment, graphNode.data),\n        next: null,\n      });\n    }\n\n    function deactivateGraphNode(force, nodeId, immutableGraph) {\n      const graph = cloneDeep(immutableGraph);\n      function recDeactivate(target, current, g) {\n        const curr = g[current];\n        if (target === current || curr.dependency === target || force) {\n          curr.active = false;\n          curr.data = emptyObject();\n        }\n        curr.children.forEach(childId => recDeactivate(target, childId, g));\n      }\n      recDeactivate(nodeId, nodeId, graph);\n      return graph;\n    }\n\n    function activateGraphNode(nodeId, data, immutableGraph) {\n      const graph = cloneDeep(immutableGraph);\n      const parents = keys(graph).filter(key => graph[key].children.indexOf(nodeId) !== -1);\n      function dfsActivate(searchId, currentId, dependencyMet) {\n        const curr = graph[currentId];\n        const search = graph[searchId];\n        if (currentId === searchId && dependencyMet) {\n          search.active = true;\n          search.data = data;\n          return true;\n        }\n        else if (currentId === searchId && !dependencyMet) {\n          return false;\n        }\n        return curr.children.reduce(\n          (depMet, childId) => dfsActivate(searchId, childId, depMet),\n          dependencyMet || currentId === search.dependency\n        );\n      }\n\n      const activated = dfsActivate(nodeId, 'root', false);\n      if (activated) {\n        // deactivate immediate siblings\n        return parents.reduce((g, parentId) =>\n          g[parentId].children.filter(id => id !== nodeId).reduce((retG, childId) =>\n            deactivateGraphNode(true, childId, retG),\n            g),\n          graph);\n      }\n      return graph;\n    }\n\n    function appendNode(node, head) {\n      const clonedHead = cloneDeep(head);\n      let next = clonedHead;\n      let last;\n      let dependencyMet = false;\n      while (next) {\n        dependencyMet = dependencyMet || next.id === node.dependency;\n        last = next;\n        next = next.next;\n      }\n      if (dependencyMet) {\n        last.next = cloneDeep(node);\n      }\n      return clonedHead;\n    }\n\n    function parseHash(hashRoute, routeGraph) {\n      function recParse(hash, rootId, visitedNodes, graph) {\n        const root = graph[rootId];\n        return root.children.reduce((g, childId) => {\n          const child = graph[childId];\n          let newG = g;\n          const matches = hash.match(segmentToRegex(child.segment)) || [];\n          const substrIndex = matches.index ? matches.index + matches[0].length : 0;\n          if (visitedNodes[childId]) {\n            return newG;\n          }\n          visitedNodes[childId] = true;\n          if (matches.length > 0 && (graph[child.dependency] || emptyObject()).active) {\n            newG = activateGraphNode(\n              childId,\n              extractSegmentData(child.segment, arrayHead(matches)),\n              graph\n            );\n          }\n          return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n        }, graph);\n      }\n      const newGraph = cloneDeep(routeGraph);\n      return recParse(hashRoute, 'root', {}, newGraph);\n    }\n\n    function buildGraph(hash) {\n      return parseHash(hash, IMMUTABLE_GRAPH);\n    }\n\n    function listToHashRoute(head) {\n      let str = '#';\n      let next = head;\n      while (next) {\n        if (next.segment) {\n          str += `${next.segment}/`;\n        }\n        next = next.next;\n      }\n      return str;\n    }\n\n    function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n      const root = graph[rootId];\n      const nextListNode = graphNodeToListNode(rootId, graph);\n      const newHead = root.active ? appendNode(nextListNode, listHead) : cloneDeep(listHead);\n\n      return root.children.reduce(\n        (head, childId) => {\n          if (visitedNodes[childId]) {\n            return head;\n          }\n          visitedNodes[childId] = true;\n          return graphToLinkedList(graph, childId, head, visitedNodes);\n        },\n        newHead\n      );\n    }\n\n    function logGraph(newGraph) {\n      const lastGraph = peek(graphStack);\n      if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n        graphStack.push(newGraph);\n      }\n      return newGraph;\n    }\n\n    function graphToList(graph) {\n      if (!graph) {\n        return null;\n      }\n      return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), emptyObject());\n    }\n\n    function notifyObservers(obsObj, oldGraph, newGraph) {\n      const oldListHead = graphToList(oldGraph);\n      const newListHead = graphToList(newGraph);\n      const missing = (() => {\n        let nxt = oldListHead;\n        const arr = [];\n        while (nxt) {\n          if (!findListNode(nxt.id, newListHead)) {\n            arr.push(nxt.id);\n          }\n          nxt = nxt.next;\n        }\n        return arr;\n      })();\n      missing.forEach((routeId) => {\n        obsObj[routeId].forEach((obs) => {\n          obs.removed();\n        });\n      });\n      let next = newListHead;\n      while (next) {\n        const observerArray = obsObj[next.id];\n        for (let i = 0; i < observerArray.length; i++) {\n          observerArray[i].inserted(chainData(newListHead, next));\n        }\n        next = next.next;\n      }\n    }\n\n    function insertOrRemove(insert, routeId, data) {\n      let dataToUse = data;\n      if (!isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n        return null;\n      }\n      if (data === null || typeof data !== 'object' || data instanceof Array) {\n        dataToUse = emptyObject();\n      }\n      const graph = buildGraph(win.location.hash);\n      let newGraph;\n      if (insert) {\n        newGraph = activateGraphNode(routeId, dataToUse, graph);\n      }\n      else {\n        newGraph = deactivateGraphNode(false, routeId, graph);\n      }\n      win.location.hash = listToHashRoute(graphToList(newGraph));\n      return this;\n    }\n    // End private methods\n\n    // Public methods\n    this.subscribe = function subscribe(subscriptions) {\n      if (!isObject(subscriptions)) {\n        return false;\n      }\n      const matchingKeys = keys(subscriptions).filter(key => !!observers[key]);\n      if (matchingKeys.length === 0) {\n        return false;\n      }\n      matchingKeys.forEach(key => {\n        const sub = subscriptions[key];\n        observers[key].push({\n          inserted: sub.inserted || noop,\n          removed: sub.removed || noop,\n        });\n      });\n      return true;\n    };\n    this.unsubscribe = function unsubscribe(route, event, handler) {\n      if (!isString(route) || !isString(event) || !isFunction(handler) || !observers[route]) {\n        return false;\n      }\n      const matchingObservers = observers[route].filter((obs) => obs[event] === handler);\n      return pull(matchingObservers, observers[route]);\n    };\n    this.insert = function insert(routeId, data) {\n      return insertOrRemove.call(this, true, routeId, data);\n    };\n    this.remove = function remove(routeId) {\n      return insertOrRemove.call(this, false, routeId);\n    };\n    this.getData = function getData() {\n      return chainData(graphToList(buildGraph(win.location.hash)));\n    };\n    this.step = function step() {\n      const originalHash = win.location.hash;\n      const graph = buildGraph(originalHash);\n      notifyObservers(observers, graphStack.pop(), graph);\n      logGraph(graph);\n      win.history.replaceState(emptyObject(), '', listToHashRoute(graphToList(graph)));\n      return this;\n    };\n\n    const listener = this.step.bind(this);\n    this.start = function start() {\n      win.addEventListener('hashchange', listener);\n      return this;\n    };\n    this.stop = function stop() {\n      win.removeEventListener('hashchange', listener);\n      return this;\n    };\n    // End public methods\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/marbles.js","function emptyObject() {\n  return Object.create(null);\n}\n\nfunction isObject(any) {\n  return typeof any === 'object' && any !== null && !(any instanceof Array);\n}\n\nfunction isString(any) {\n  return typeof any === 'string';\n}\n\nfunction isFunction(any) {\n  return typeof any === 'function';\n}\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction assign(...args) {\n  return Object.assign.apply(this, args);\n}\n\nfunction arrayHead(array) {\n  if (typeof array === 'undefined' || !(array instanceof Array)) {\n    return undefined;\n  }\n  return array[0];\n}\n\nfunction pull(values, array) {\n  return values.map((val) => {\n    let index = array.indexOf(val);\n    let results = [];\n    while (index !== -1) {\n      results = results.concat(array.splice(index, 1));\n      index = array.indexOf(val);\n    }\n    return results;\n  })\n  .reduce((returnArray, subArray) => returnArray.concat(subArray), [])\n  .reduce((returnArray, val) => {\n    if (returnArray.indexOf(val) !== -1) {\n      return returnArray;\n    }\n    return returnArray.concat(val instanceof Array ? [val] : val);\n  }, []);\n}\n\nfunction without(values, array) {\n  const newArray = array.slice();\n  pull(values, newArray);\n  return newArray;\n}\n\nfunction peek(arr) {\n  if (!arr || !(arr instanceof Array)) {\n    return null;\n  }\n  return arr[arr.length-1] || null;\n}\n\nfunction noop() {}\n\nexport {\n  emptyObject,\n  isObject,\n  isFunction,\n  isString,\n  noop,\n  keys,\n  peek,\n  cloneDeep,\n  assign,\n  arrayHead,\n  pull,\n  without\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js"],"sourceRoot":""}