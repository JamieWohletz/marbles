{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marbles.min.js","webpack:///webpack/bootstrap 52e7da42934e722378c6","webpack:///./src/marbles.js","webpack:///./src/util.js","webpack:///./~/deep-equal/index.js","webpack:///./~/deep-equal/lib/is_arguments.js","webpack:///./~/deep-equal/lib/keys.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_util","util","Marbles","routingGraph","expandSegment","segment","data","replace","DYNAMIC_SEGMENT_REGEX","segmentKey","extractSegmentData","templateSegment","segmentWithData","dynamicSegments","match","RegExp","source","DIGIT_SEGMENT_REGEX","reduce","index","assign","emptyObject","segmentToRegex","regexed","findListNode","nodeId","list","next","chainData","upToNode","stop","isObject","graphNodeToListNode","graph","graphNode","deactivateGraphNode","force","immutableGraph","recDeactivate","target","current","g","curr","dependency","active","children","forEach","childId","cloneDeep","activateGraphNode","dfsActivate","searchId","currentId","dependencyMet","search","depMet","parents","keys","filter","indexOf","activated","parentId","retG","appendNode","node","head","clonedHead","last","parseHash","hashRoute","routeGraph","recParse","hash","rootId","visitedNodes","child","newG","matches","substrIndex","length","arrayHead","substr","newGraph","buildGraph","IMMUTABLE_GRAPH","listToHashRoute","listReduce","graphToLinkedList","listHead","nextListNode","newHead","logGraph","lastGraph","peek","graphStack","JSON","stringify","push","graphToList","listDiff","from","against","arr","found","equal","concat","notifyObservers","obsObj","oldGraph","oldListHead","newListHead","removed","insertedNodes","obs","listForEach","inserted","insertOrRemove","insert","routeId","dataToUse","isString","Array","win","location","arguments","undefined","window","observers","subscribe","subscriptions","matchingKeys","sub","noop","unsubscribe","route","event","handler","isFunction","matchingObservers","pull","remove","getData","step","pop","history","replaceState","listener","bind","start","addEventListener","removeEventListener","create","any","isArray","parse","_len","args","_key","apply","array","values","map","val","results","splice","returnArray","subArray","without","newArray","slice","isList","listish","assertList","i","listMap","newNodes","reduceRight","tail","reducer","accumulator","foldl","f","a","batchAsyncActions","fns","callback","resolvedCount","fn","result","deepEqual","isUndefinedOrNull","isBuffer","x","copy","objEquiv","b","opts","isArguments","pSlice","ka","objectKeys","kb","e","sort","actual","expected","Date","getTime","strict","supported","object","toString","unsupported","propertyIsEnumerable","supportsArgumentsClass","shim"],"mappings":"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","file":"marbles.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar util = _interopRequireWildcard(_util);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Marbles = function Marbles(routingGraph) {\n\t  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\t\n\t  _classCallCheck(this, Marbles);\n\t\n\t  var IMMUTABLE_GRAPH = routingGraph;\n\t  var DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n\t  var DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n\t  var observers = util.keys(IMMUTABLE_GRAPH).reduce(function (obj, key) {\n\t    obj[key] = [];\n\t    return obj;\n\t  }, util.emptyObject());\n\t  var graphStack = [];\n\t\n\t  // Private methods\n\t  function expandSegment(segment, data) {\n\t    return segment.replace(DYNAMIC_SEGMENT_REGEX, function (segmentKey) {\n\t      return data[segmentKey.replace(':', '')];\n\t    });\n\t  }\n\t\n\t  function extractSegmentData(templateSegment, segmentWithData) {\n\t    var dynamicSegments = templateSegment.match(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')) || [];\n\t    return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce(function (data, value, index) {\n\t      data[dynamicSegments[index].replace(':', '')] = value;\n\t      return util.assign(util.emptyObject(), data);\n\t    }, util.emptyObject());\n\t  }\n\t\n\t  function segmentToRegex(segment) {\n\t    // It just got weird\n\t    var regexed = segment.replace(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'), DIGIT_SEGMENT_REGEX.source);\n\t    return new RegExp(regexed);\n\t  }\n\t\n\t  function findListNode(nodeId, list) {\n\t    var next = list;\n\t    while (next) {\n\t      if (next.id === nodeId) {\n\t        return next;\n\t      }\n\t      next = next.next;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function chainData(list, upToNode) {\n\t    var data = util.emptyObject();\n\t    var stop = util.isObject(upToNode) ? upToNode : { data: {} };\n\t    var next = list;\n\t    while (next && next !== stop) {\n\t      util.assign(data, next.data);\n\t      next = next.next;\n\t    }\n\t    return util.assign(data, stop.data);\n\t  }\n\t\n\t  function graphNodeToListNode(id, graph) {\n\t    var graphNode = graph[id];\n\t    return util.assign(util.emptyObject(), graphNode, {\n\t      id: id,\n\t      segment: expandSegment(graphNode.segment, graphNode.data),\n\t      next: null\n\t    });\n\t  }\n\t\n\t  function deactivateGraphNode(force, nodeId, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    function recDeactivate(target, current, g) {\n\t      var curr = g[current];\n\t      if (target === current || curr.dependency === target || force) {\n\t        curr.active = false;\n\t        curr.data = util.emptyObject();\n\t      }\n\t      curr.children.forEach(function (childId) {\n\t        return recDeactivate(target, childId, g);\n\t      });\n\t    }\n\t    recDeactivate(nodeId, nodeId, graph);\n\t    return graph;\n\t  }\n\t\n\t  function activateGraphNode(nodeId, data, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    var parents = util.keys(graph).filter(function (key) {\n\t      return graph[key].children.indexOf(nodeId) !== -1;\n\t    });\n\t    function dfsActivate(searchId, currentId, dependencyMet) {\n\t      var curr = graph[currentId];\n\t      var search = graph[searchId];\n\t      if (currentId === searchId && dependencyMet) {\n\t        search.active = true;\n\t        search.data = data;\n\t        return true;\n\t      } else if (currentId === searchId && !dependencyMet) {\n\t        return false;\n\t      }\n\t      return curr.children.reduce(function (depMet, childId) {\n\t        return dfsActivate(searchId, childId, depMet);\n\t      }, dependencyMet || currentId === search.dependency);\n\t    }\n\t\n\t    var activated = dfsActivate(nodeId, 'root', false);\n\t    if (activated) {\n\t      // deactivate immediate siblings\n\t      return parents.reduce(function (g, parentId) {\n\t        return g[parentId].children.filter(function (id) {\n\t          return id !== nodeId;\n\t        }).reduce(function (retG, childId) {\n\t          return deactivateGraphNode(true, childId, retG);\n\t        }, g);\n\t      }, graph);\n\t    }\n\t    return graph;\n\t  }\n\t\n\t  function appendNode(node, head) {\n\t    var clonedHead = util.cloneDeep(head);\n\t    var next = clonedHead;\n\t    var last = void 0;\n\t    var dependencyMet = false;\n\t    while (next) {\n\t      dependencyMet = dependencyMet || next.id === node.dependency;\n\t      last = next;\n\t      next = next.next;\n\t    }\n\t    if (dependencyMet) {\n\t      last.next = util.cloneDeep(node);\n\t    }\n\t    return clonedHead;\n\t  }\n\t\n\t  function parseHash(hashRoute, routeGraph) {\n\t    function recParse(hash, rootId, visitedNodes, graph) {\n\t      var root = graph[rootId];\n\t      return root.children.reduce(function (g, childId) {\n\t        var child = graph[childId];\n\t        var newG = g;\n\t        var matches = hash.match(segmentToRegex(child.segment)) || [];\n\t        var substrIndex = matches.index ? matches.index + matches[0].length : 0;\n\t        if (visitedNodes[childId]) {\n\t          return newG;\n\t        }\n\t        visitedNodes[childId] = true;\n\t        if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\n\t          newG = activateGraphNode(childId, extractSegmentData(child.segment, util.arrayHead(matches)), graph);\n\t        }\n\t        return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n\t      }, graph);\n\t    }\n\t    var newGraph = util.cloneDeep(routeGraph);\n\t    return recParse(hashRoute, 'root', {}, newGraph);\n\t  }\n\t\n\t  function buildGraph(hash) {\n\t    return parseHash(hash, IMMUTABLE_GRAPH);\n\t  }\n\t\n\t  function listToHashRoute(head) {\n\t    return util.listReduce(function (hash, node) {\n\t      if (node.segment) {\n\t        return '' + hash + node.segment + '/';\n\t      }\n\t      return hash;\n\t    }, '#', head);\n\t  }\n\t\n\t  function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n\t    var root = graph[rootId];\n\t    var nextListNode = graphNodeToListNode(rootId, graph);\n\t    var newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\n\t\n\t    return root.children.reduce(function (head, childId) {\n\t      if (visitedNodes[childId]) {\n\t        return head;\n\t      }\n\t      visitedNodes[childId] = true;\n\t      return graphToLinkedList(graph, childId, head, visitedNodes);\n\t    }, newHead);\n\t  }\n\t\n\t  function logGraph(newGraph) {\n\t    var lastGraph = util.peek(graphStack);\n\t    if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n\t      graphStack.push(newGraph);\n\t    }\n\t    return newGraph;\n\t  }\n\t\n\t  function graphToList(graph) {\n\t    if (!graph) {\n\t      return null;\n\t    }\n\t    return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), util.emptyObject());\n\t  }\n\t\n\t  function listDiff(from, against) {\n\t    return util.listReduce(function (arr, node) {\n\t      var found = findListNode(node.id, against);\n\t      if (!found || !util.equal(found.data, node.data)) {\n\t        return arr.concat(node);\n\t      }\n\t      return arr;\n\t    }, [], from);\n\t  }\n\t\n\t  function notifyObservers(obsObj, oldGraph, newGraph) {\n\t    var oldListHead = graphToList(oldGraph);\n\t    var newListHead = graphToList(newGraph);\n\t    var removed = listDiff(oldListHead, newListHead);\n\t    var insertedNodes = listDiff(newListHead, oldListHead);\n\t    removed.forEach(function (node) {\n\t      obsObj[node.id].forEach(function (obs) {\n\t        obs.removed(chainData(oldListHead, node));\n\t      });\n\t    });\n\t    util.listForEach(function (node) {\n\t      obsObj[node.id].forEach(function (obs) {\n\t        obs.inserted(chainData(newListHead, node));\n\t      });\n\t    }, insertedNodes[0] || null);\n\t  }\n\t\n\t  function insertOrRemove(insert, routeId, data) {\n\t    var dataToUse = data;\n\t    if (!util.isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n\t      return null;\n\t    }\n\t    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data instanceof Array) {\n\t      dataToUse = util.emptyObject();\n\t    }\n\t    var graph = buildGraph(win.location.hash);\n\t    var newGraph = void 0;\n\t    if (insert) {\n\t      newGraph = activateGraphNode(routeId, dataToUse, graph);\n\t    } else {\n\t      newGraph = deactivateGraphNode(false, routeId, graph);\n\t    }\n\t    win.location.hash = listToHashRoute(graphToList(newGraph));\n\t    return this;\n\t  }\n\t  // End private methods\n\t\n\t  // Public methods\n\t  this.subscribe = function subscribe(subscriptions) {\n\t    if (!util.isObject(subscriptions)) {\n\t      return false;\n\t    }\n\t    var matchingKeys = util.keys(subscriptions).filter(function (key) {\n\t      return !!observers[key];\n\t    });\n\t    if (matchingKeys.length === 0) {\n\t      return false;\n\t    }\n\t    matchingKeys.forEach(function (key) {\n\t      var sub = subscriptions[key];\n\t      observers[key].push({\n\t        inserted: sub.inserted || util.noop,\n\t        removed: sub.removed || util.noop\n\t      });\n\t    });\n\t    return true;\n\t  };\n\t  this.unsubscribe = function unsubscribe(route, event, handler) {\n\t    if (!util.isString(route) || !util.isString(event) || !util.isFunction(handler) || !observers[route]) {\n\t      return false;\n\t    }\n\t    var matchingObservers = observers[route].filter(function (obs) {\n\t      return obs[event] === handler;\n\t    });\n\t    return util.pull(matchingObservers, observers[route]);\n\t  };\n\t  this.insert = function insert(routeId, data) {\n\t    return insertOrRemove.call(this, true, routeId, data);\n\t  };\n\t  this.remove = function remove(routeId) {\n\t    return insertOrRemove.call(this, false, routeId);\n\t  };\n\t  this.getData = function getData() {\n\t    return chainData(graphToList(buildGraph(win.location.hash)));\n\t  };\n\t  this.step = function step() {\n\t    var hash = win.location.hash;\n\t    var graph = buildGraph(hash);\n\t    notifyObservers(observers, graphStack.pop(), graph);\n\t    logGraph(graph);\n\t    win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(graph)));\n\t    return this;\n\t  };\n\t\n\t  var listener = this.step.bind(this);\n\t  this.start = function start() {\n\t    win.addEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  this.stop = function stop() {\n\t    win.removeEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  // End public methods\n\t};\n\t\n\texports.default = Marbles;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar deepEqual = __webpack_require__(2);\n\t\n\tfunction emptyObject() {\n\t  return Object.create(null);\n\t}\n\t\n\tfunction isObject(any) {\n\t  return (typeof any === 'undefined' ? 'undefined' : _typeof(any)) === 'object' && any !== null && !(any instanceof Array);\n\t}\n\t\n\tfunction isArray(any) {\n\t  return any instanceof Array;\n\t}\n\t\n\tfunction isString(any) {\n\t  return typeof any === 'string';\n\t}\n\t\n\tfunction isFunction(any) {\n\t  return typeof any === 'function';\n\t}\n\t\n\tfunction keys(obj) {\n\t  return Object.keys(obj);\n\t}\n\t\n\tfunction cloneDeep(obj) {\n\t  return JSON.parse(JSON.stringify(obj));\n\t}\n\t\n\tfunction assign() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return Object.assign.apply(this, args);\n\t}\n\t\n\tfunction arrayHead(array) {\n\t  if (typeof array === 'undefined' || !(array instanceof Array)) {\n\t    return undefined;\n\t  }\n\t  return array[0];\n\t}\n\t\n\tfunction pull(values, array) {\n\t  return values.map(function (val) {\n\t    var index = array.indexOf(val);\n\t    var results = [];\n\t    while (index !== -1) {\n\t      results = results.concat(array.splice(index, 1));\n\t      index = array.indexOf(val);\n\t    }\n\t    return results;\n\t  }).reduce(function (returnArray, subArray) {\n\t    return returnArray.concat(subArray);\n\t  }, []).reduce(function (returnArray, val) {\n\t    if (returnArray.indexOf(val) !== -1) {\n\t      return returnArray;\n\t    }\n\t    return returnArray.concat(val instanceof Array ? [val] : val);\n\t  }, []);\n\t}\n\t\n\tfunction without(values, array) {\n\t  var newArray = array.slice();\n\t  pull(values, newArray);\n\t  return newArray;\n\t}\n\t\n\tfunction peek(arr) {\n\t  if (!arr || !(arr instanceof Array)) {\n\t    return null;\n\t  }\n\t  return arr[arr.length - 1] || null;\n\t}\n\t\n\tfunction noop() {}\n\t\n\tfunction isList(listish) {\n\t  return listish === null || isObject(listish) && _typeof(listish.next) === 'object';\n\t}\n\t\n\tfunction assertList(list) {\n\t  if (!isList(list)) {\n\t    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\n\t  }\n\t}\n\t\n\tfunction listForEach(iterator, list) {\n\t  assertList(list);\n\t  var next = list;\n\t  var i = 0;\n\t  while (next) {\n\t    iterator(next, i);\n\t    next = next.next;\n\t    i = i + 1;\n\t  }\n\t}\n\t\n\tfunction listMap(iterator, list) {\n\t  var newNodes = [];\n\t  listForEach(function (node, index) {\n\t    newNodes.push(iterator(node, index));\n\t  }, list);\n\t  return newNodes.reduceRight(function (tail, node) {\n\t    return assign({}, node, {\n\t      next: tail\n\t    });\n\t  }, null);\n\t}\n\t\n\tfunction listReduce(reducer, accumulator, list) {\n\t  return function foldl(f, a, head, i) {\n\t    if (head === null) {\n\t      return a;\n\t    }\n\t    assertList(head);\n\t    return foldl(f, f(a, head, i), head.next, i + 1);\n\t  }(reducer, accumulator, list, 0);\n\t}\n\t\n\tfunction batchAsyncActions(fns, callback) {\n\t  if (!isArray(fns)) {\n\t    throw new TypeError('batchAsyncResults() expects an array of functions as the first parameter.');\n\t  }\n\t  var resolvedCount = 0;\n\t  var results = [];\n\t  fns.forEach(function (fn) {\n\t    fn(function (result) {\n\t      resolvedCount += 1;\n\t      results.push(result);\n\t      if (resolvedCount === fns.length) {\n\t        callback(results);\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\texports.equal = deepEqual;\n\texports.emptyObject = emptyObject;\n\texports.isArray = isArray;\n\texports.isObject = isObject;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isList = isList;\n\texports.listForEach = listForEach;\n\texports.listMap = listMap;\n\texports.listReduce = listReduce;\n\texports.batchAsyncActions = batchAsyncActions;\n\texports.noop = noop;\n\texports.keys = keys;\n\texports.peek = peek;\n\texports.cloneDeep = cloneDeep;\n\texports.assign = assign;\n\texports.arrayHead = arrayHead;\n\texports.pull = pull;\n\texports.without = without;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pSlice = Array.prototype.slice;\n\tvar objectKeys = __webpack_require__(4);\n\tvar isArguments = __webpack_require__(3);\n\t\n\tvar deepEqual = module.exports = function (actual, expected, opts) {\n\t  if (!opts) opts = {};\n\t  // 7.1. All identical values are equivalent, as determined by ===.\n\t  if (actual === expected) {\n\t    return true;\n\t\n\t  } else if (actual instanceof Date && expected instanceof Date) {\n\t    return actual.getTime() === expected.getTime();\n\t\n\t  // 7.3. Other pairs that do not both pass typeof value == 'object',\n\t  // equivalence is determined by ==.\n\t  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n\t    return opts.strict ? actual === expected : actual == expected;\n\t\n\t  // 7.4. For all other Object pairs, including Array objects, equivalence is\n\t  // determined by having the same number of owned properties (as verified\n\t  // with Object.prototype.hasOwnProperty.call), the same set of keys\n\t  // (although not necessarily the same order), equivalent values for every\n\t  // corresponding key, and an identical 'prototype' property. Note: this\n\t  // accounts for both named and indexed properties on Arrays.\n\t  } else {\n\t    return objEquiv(actual, expected, opts);\n\t  }\n\t}\n\t\n\tfunction isUndefinedOrNull(value) {\n\t  return value === null || value === undefined;\n\t}\n\t\n\tfunction isBuffer (x) {\n\t  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n\t  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n\t    return false;\n\t  }\n\t  if (x.length > 0 && typeof x[0] !== 'number') return false;\n\t  return true;\n\t}\n\t\n\tfunction objEquiv(a, b, opts) {\n\t  var i, key;\n\t  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n\t    return false;\n\t  // an identical 'prototype' property.\n\t  if (a.prototype !== b.prototype) return false;\n\t  //~~~I've managed to break Object.keys through screwy arguments passing.\n\t  //   Converting to array solves the problem.\n\t  if (isArguments(a)) {\n\t    if (!isArguments(b)) {\n\t      return false;\n\t    }\n\t    a = pSlice.call(a);\n\t    b = pSlice.call(b);\n\t    return deepEqual(a, b, opts);\n\t  }\n\t  if (isBuffer(a)) {\n\t    if (!isBuffer(b)) {\n\t      return false;\n\t    }\n\t    if (a.length !== b.length) return false;\n\t    for (i = 0; i < a.length; i++) {\n\t      if (a[i] !== b[i]) return false;\n\t    }\n\t    return true;\n\t  }\n\t  try {\n\t    var ka = objectKeys(a),\n\t        kb = objectKeys(b);\n\t  } catch (e) {//happens when one is a string literal and the other isn't\n\t    return false;\n\t  }\n\t  // having the same number of owned properties (keys incorporates\n\t  // hasOwnProperty)\n\t  if (ka.length != kb.length)\n\t    return false;\n\t  //the same set of keys (although not necessarily the same order),\n\t  ka.sort();\n\t  kb.sort();\n\t  //~~~cheap key test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    if (ka[i] != kb[i])\n\t      return false;\n\t  }\n\t  //equivalent values for every corresponding key, and\n\t  //~~~possibly expensive deep test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    key = ka[i];\n\t    if (!deepEqual(a[key], b[key], opts)) return false;\n\t  }\n\t  return typeof a === typeof b;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar supportsArgumentsClass = (function(){\n\t  return Object.prototype.toString.call(arguments)\n\t})() == '[object Arguments]';\n\t\n\texports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\t\n\texports.supported = supported;\n\tfunction supported(object) {\n\t  return Object.prototype.toString.call(object) == '[object Arguments]';\n\t};\n\t\n\texports.unsupported = unsupported;\n\tfunction unsupported(object){\n\t  return object &&\n\t    typeof object == 'object' &&\n\t    typeof object.length == 'number' &&\n\t    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n\t    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n\t    false;\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\texports = module.exports = typeof Object.keys === 'function'\n\t  ? Object.keys : shim;\n\t\n\texports.shim = shim;\n\tfunction shim (obj) {\n\t  var keys = [];\n\t  for (var key in obj) keys.push(key);\n\t  return keys;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// marbles.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 52e7da42934e722378c6","import * as util from './util.js';\r\n\r\nexport default class Marbles {\r\n  constructor(routingGraph, win = window) {\r\n    const IMMUTABLE_GRAPH = routingGraph;\r\n    const DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\r\n    const DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\r\n    const observers = util.keys(IMMUTABLE_GRAPH).reduce((obj, key) => {\r\n      obj[key] = [];\r\n      return obj;\r\n    }, util.emptyObject());\r\n    const graphStack = [];\r\n\r\n    // Private methods\r\n    function expandSegment(segment, data) {\r\n      return segment.replace(\r\n        DYNAMIC_SEGMENT_REGEX,\r\n        segmentKey => data[segmentKey.replace(':', '')]\r\n      );\r\n    }\r\n\r\n    function extractSegmentData(templateSegment, segmentWithData) {\r\n      const dynamicSegments = templateSegment.match(\r\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')\r\n      ) || [];\r\n      return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce((data, value, index) => {\r\n        data[dynamicSegments[index].replace(':', '')] = value;\r\n        return util.assign(util.emptyObject(), data);\r\n      },\r\n        util.emptyObject()\r\n      );\r\n    }\r\n\r\n    function segmentToRegex(segment) {\r\n      // It just got weird\r\n      const regexed = segment.replace(\r\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'),\r\n        DIGIT_SEGMENT_REGEX.source\r\n      );\r\n      return new RegExp(regexed);\r\n    }\r\n\r\n    function findListNode(nodeId, list) {\r\n      let next = list;\r\n      while (next) {\r\n        if (next.id === nodeId) {\r\n          return next;\r\n        }\r\n        next = next.next;\r\n      }\r\n      return null;\r\n    }\r\n\r\n    function chainData(list, upToNode) {\r\n      const data = util.emptyObject();\r\n      const stop = util.isObject(upToNode) ? upToNode : { data: {} };\r\n      let next = list;\r\n      while (next && next !== stop) {\r\n        util.assign(data, next.data);\r\n        next = next.next;\r\n      }\r\n      return util.assign(data, stop.data);\r\n    }\r\n\r\n    function graphNodeToListNode(id, graph) {\r\n      const graphNode = graph[id];\r\n      return util.assign(util.emptyObject(), graphNode, {\r\n        id,\r\n        segment: expandSegment(graphNode.segment, graphNode.data),\r\n        next: null,\r\n      });\r\n    }\r\n\r\n    function deactivateGraphNode(force, nodeId, immutableGraph) {\r\n      const graph = util.cloneDeep(immutableGraph);\r\n      function recDeactivate(target, current, g) {\r\n        const curr = g[current];\r\n        if (target === current || curr.dependency === target || force) {\r\n          curr.active = false;\r\n          curr.data = util.emptyObject();\r\n        }\r\n        curr.children.forEach(childId => recDeactivate(target, childId, g));\r\n      }\r\n      recDeactivate(nodeId, nodeId, graph);\r\n      return graph;\r\n    }\r\n\r\n    function activateGraphNode(nodeId, data, immutableGraph) {\r\n      const graph = util.cloneDeep(immutableGraph);\r\n      const parents = util.keys(graph).filter(key => graph[key].children.indexOf(nodeId) !== -1);\r\n      function dfsActivate(searchId, currentId, dependencyMet) {\r\n        const curr = graph[currentId];\r\n        const search = graph[searchId];\r\n        if (currentId === searchId && dependencyMet) {\r\n          search.active = true;\r\n          search.data = data;\r\n          return true;\r\n        }\r\n        else if (currentId === searchId && !dependencyMet) {\r\n          return false;\r\n        }\r\n        return curr.children.reduce(\r\n          (depMet, childId) => dfsActivate(searchId, childId, depMet),\r\n          dependencyMet || currentId === search.dependency\r\n        );\r\n      }\r\n\r\n      const activated = dfsActivate(nodeId, 'root', false);\r\n      if (activated) {\r\n        // deactivate immediate siblings\r\n        return parents.reduce((g, parentId) =>\r\n          g[parentId].children.filter(id => id !== nodeId).reduce((retG, childId) =>\r\n            deactivateGraphNode(true, childId, retG),\r\n            g),\r\n          graph);\r\n      }\r\n      return graph;\r\n    }\r\n\r\n    function appendNode(node, head) {\r\n      const clonedHead = util.cloneDeep(head);\r\n      let next = clonedHead;\r\n      let last;\r\n      let dependencyMet = false;\r\n      while (next) {\r\n        dependencyMet = dependencyMet || next.id === node.dependency;\r\n        last = next;\r\n        next = next.next;\r\n      }\r\n      if (dependencyMet) {\r\n        last.next = util.cloneDeep(node);\r\n      }\r\n      return clonedHead;\r\n    }\r\n\r\n    function parseHash(hashRoute, routeGraph) {\r\n      function recParse(hash, rootId, visitedNodes, graph) {\r\n        const root = graph[rootId];\r\n        return root.children.reduce((g, childId) => {\r\n          const child = graph[childId];\r\n          let newG = g;\r\n          const matches = hash.match(segmentToRegex(child.segment)) || [];\r\n          const substrIndex = matches.index ? matches.index + matches[0].length : 0;\r\n          if (visitedNodes[childId]) {\r\n            return newG;\r\n          }\r\n          visitedNodes[childId] = true;\r\n          if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\r\n            newG = activateGraphNode(\r\n              childId,\r\n              extractSegmentData(child.segment, util.arrayHead(matches)),\r\n              graph\r\n            );\r\n          }\r\n          return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\r\n        }, graph);\r\n      }\r\n      const newGraph = util.cloneDeep(routeGraph);\r\n      return recParse(hashRoute, 'root', {}, newGraph);\r\n    }\r\n\r\n    function buildGraph(hash) {\r\n      return parseHash(hash, IMMUTABLE_GRAPH);\r\n    }\r\n\r\n    function listToHashRoute(head) {\r\n      return util.listReduce((hash, node) => {\r\n        if (node.segment) {\r\n          return `${hash}${node.segment}/`;\r\n        }\r\n        return hash;\r\n      }, '#', head);\r\n    }\r\n\r\n    function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\r\n      const root = graph[rootId];\r\n      const nextListNode = graphNodeToListNode(rootId, graph);\r\n      const newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\r\n\r\n      return root.children.reduce(\r\n        (head, childId) => {\r\n          if (visitedNodes[childId]) {\r\n            return head;\r\n          }\r\n          visitedNodes[childId] = true;\r\n          return graphToLinkedList(graph, childId, head, visitedNodes);\r\n        },\r\n        newHead\r\n      );\r\n    }\r\n\r\n    function logGraph(newGraph) {\r\n      const lastGraph = util.peek(graphStack);\r\n      if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\r\n        graphStack.push(newGraph);\r\n      }\r\n      return newGraph;\r\n    }\r\n\r\n    function graphToList(graph) {\r\n      if (!graph) {\r\n        return null;\r\n      }\r\n      return graphToLinkedList(\r\n        graph,\r\n        'root',\r\n        graphNodeToListNode('root', graph),\r\n        util.emptyObject()\r\n      );\r\n    }\r\n\r\n    function listDiff(from, against) {\r\n      return util.listReduce((arr, node) => {\r\n        const found = findListNode(node.id, against);\r\n        if (!found || !util.equal(found.data, node.data)) {\r\n          return arr.concat(node);\r\n        }\r\n        return arr;\r\n      }, [], from);\r\n    }\r\n\r\n    function notifyObservers(obsObj, oldGraph, newGraph) {\r\n      const oldListHead = graphToList(oldGraph);\r\n      const newListHead = graphToList(newGraph);\r\n      const removed = listDiff(oldListHead, newListHead);\r\n      const insertedNodes = listDiff(newListHead, oldListHead);\r\n      removed.forEach((node) => {\r\n        obsObj[node.id].forEach((obs) => {\r\n          obs.removed(chainData(oldListHead, node));\r\n        });\r\n      });\r\n      util.listForEach((node) => {\r\n        obsObj[node.id].forEach((obs) => {\r\n          obs.inserted(chainData(newListHead, node));\r\n        });\r\n      }, insertedNodes[0] || null);\r\n    }\r\n\r\n    function insertOrRemove(insert, routeId, data) {\r\n      let dataToUse = data;\r\n      if (!util.isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\r\n        return null;\r\n      }\r\n      if (data === null || typeof data !== 'object' || data instanceof Array) {\r\n        dataToUse = util.emptyObject();\r\n      }\r\n      const graph = buildGraph(win.location.hash);\r\n      let newGraph;\r\n      if (insert) {\r\n        newGraph = activateGraphNode(routeId, dataToUse, graph);\r\n      }\r\n      else {\r\n        newGraph = deactivateGraphNode(false, routeId, graph);\r\n      }\r\n      win.location.hash = listToHashRoute(graphToList(newGraph));\r\n      return this;\r\n    }\r\n    // End private methods\r\n\r\n    // Public methods\r\n    this.subscribe = function subscribe(subscriptions) {\r\n      if (!util.isObject(subscriptions)) {\r\n        return false;\r\n      }\r\n      const matchingKeys = util.keys(subscriptions).filter(key => !!observers[key]);\r\n      if (matchingKeys.length === 0) {\r\n        return false;\r\n      }\r\n      matchingKeys.forEach(key => {\r\n        const sub = subscriptions[key];\r\n        observers[key].push({\r\n          inserted: sub.inserted || util.noop,\r\n          removed: sub.removed || util.noop,\r\n        });\r\n      });\r\n      return true;\r\n    };\r\n    this.unsubscribe = function unsubscribe(route, event, handler) {\r\n      if (\r\n        !util.isString(route) ||\r\n        !util.isString(event) ||\r\n        !util.isFunction(handler) ||\r\n        !observers[route]\r\n      ) {\r\n        return false;\r\n      }\r\n      const matchingObservers = observers[route].filter((obs) => obs[event] === handler);\r\n      return util.pull(matchingObservers, observers[route]);\r\n    };\r\n    this.insert = function insert(routeId, data) {\r\n      return insertOrRemove.call(this, true, routeId, data);\r\n    };\r\n    this.remove = function remove(routeId) {\r\n      return insertOrRemove.call(this, false, routeId);\r\n    };\r\n    this.getData = function getData() {\r\n      return chainData(graphToList(buildGraph(win.location.hash)));\r\n    };\r\n    this.step = function step() {\r\n      const hash = win.location.hash;\r\n      const graph = buildGraph(hash);\r\n      notifyObservers(observers, graphStack.pop(), graph);\r\n      logGraph(graph);\r\n      win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(graph)));\r\n      return this;\r\n    };\r\n\r\n    const listener = this.step.bind(this);\r\n    this.start = function start() {\r\n      win.addEventListener('hashchange', listener);\r\n      return this;\r\n    };\r\n    this.stop = function stop() {\r\n      win.removeEventListener('hashchange', listener);\r\n      return this;\r\n    };\r\n    // End public methods\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/marbles.js","const deepEqual = require('deep-equal');\r\n\r\nfunction emptyObject() {\r\n  return Object.create(null);\r\n}\r\n\r\nfunction isObject(any) {\r\n  return typeof any === 'object' && any !== null && !(any instanceof Array);\r\n}\r\n\r\nfunction isArray(any) {\r\n  return any instanceof Array;\r\n}\r\n\r\nfunction isString(any) {\r\n  return typeof any === 'string';\r\n}\r\n\r\nfunction isFunction(any) {\r\n  return typeof any === 'function';\r\n}\r\n\r\nfunction keys(obj) {\r\n  return Object.keys(obj);\r\n}\r\n\r\nfunction cloneDeep(obj) {\r\n  return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nfunction assign(...args) {\r\n  return Object.assign.apply(this, args);\r\n}\r\n\r\nfunction arrayHead(array) {\r\n  if (typeof array === 'undefined' || !(array instanceof Array)) {\r\n    return undefined;\r\n  }\r\n  return array[0];\r\n}\r\n\r\nfunction pull(values, array) {\r\n  return values.map((val) => {\r\n    let index = array.indexOf(val);\r\n    let results = [];\r\n    while (index !== -1) {\r\n      results = results.concat(array.splice(index, 1));\r\n      index = array.indexOf(val);\r\n    }\r\n    return results;\r\n  })\r\n    .reduce((returnArray, subArray) => returnArray.concat(subArray), [])\r\n    .reduce((returnArray, val) => {\r\n      if (returnArray.indexOf(val) !== -1) {\r\n        return returnArray;\r\n      }\r\n      return returnArray.concat(val instanceof Array ? [val] : val);\r\n    }, []);\r\n}\r\n\r\nfunction without(values, array) {\r\n  const newArray = array.slice();\r\n  pull(values, newArray);\r\n  return newArray;\r\n}\r\n\r\nfunction peek(arr) {\r\n  if (!arr || !(arr instanceof Array)) {\r\n    return null;\r\n  }\r\n  return arr[arr.length - 1] || null;\r\n}\r\n\r\nfunction noop() { }\r\n\r\nfunction isList(listish) {\r\n  return listish === null || (isObject(listish) && typeof listish.next === 'object');\r\n}\r\n\r\nfunction assertList(list) {\r\n  if (!isList(list)) {\r\n    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\r\n  }\r\n}\r\n\r\nfunction listForEach(iterator, list) {\r\n  assertList(list);\r\n  let next = list;\r\n  let i = 0;\r\n  while (next) {\r\n    iterator(next, i);\r\n    next = next.next;\r\n    i = i + 1;\r\n  }\r\n}\r\n\r\nfunction listMap(iterator, list) {\r\n  const newNodes = [];\r\n  listForEach((node, index) => {\r\n    newNodes.push(iterator(node, index));\r\n  }, list);\r\n  return newNodes.reduceRight((tail, node) => assign({}, node, {\r\n    next: tail\r\n  }), null);\r\n}\r\n\r\nfunction listReduce(reducer, accumulator, list) {\r\n  return (function foldl(f, a, head, i) {\r\n    if (head === null) {\r\n      return a;\r\n    }\r\n    assertList(head);\r\n    return foldl(f, f(a, head, i), head.next, i + 1);\r\n  }(reducer, accumulator, list, 0));\r\n}\r\n\r\nfunction batchAsyncActions(fns, callback) {\r\n  if (!isArray(fns)) {\r\n    throw new TypeError(\r\n      'batchAsyncResults() expects an array of functions as the first parameter.'\r\n    );\r\n  }\r\n  let resolvedCount = 0;\r\n  const results = [];\r\n  fns.forEach((fn) => {\r\n    fn((result) => {\r\n      resolvedCount += 1;\r\n      results.push(result);\r\n      if (resolvedCount === fns.length) {\r\n        callback(results);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nexport {\r\n  deepEqual as equal,\r\n  emptyObject,\r\n  isArray,\r\n  isObject,\r\n  isFunction,\r\n  isString,\r\n  isList,\r\n  listForEach,\r\n  listMap,\r\n  listReduce,\r\n  batchAsyncActions,\r\n  noop,\r\n  keys,\r\n  peek,\r\n  cloneDeep,\r\n  assign,\r\n  arrayHead,\r\n  pull,\r\n  without\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/index.js\n// module id = 2\n// module chunks = 0","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/is_arguments.js\n// module id = 3\n// module chunks = 0","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/keys.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}