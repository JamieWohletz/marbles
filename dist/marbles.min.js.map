{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marbles.min.js","webpack:///webpack/bootstrap aaec09ae39c8d97f0d60","webpack:///./src/marbles.js","webpack:///./src/util.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","prototype","_util","Marbles","routingGraph","expandSegment","segment","data","replace","DYNAMIC_SEGMENT_REGEX","segmentKey","extractSegmentData","templateSegment","segmentWithData","dynamicSegments","match","RegExp","source","DIGIT_SEGMENT_REGEX","reduce","index","assign","emptyObject","segmentToRegex","regexed","findListNode","nodeId","list","next","chainData","upToNode","graphNodeToListNode","graph","graphNode","deactivateGraphNode","force","immutableGraph","recDeactivate","target","current","g","curr","dependency","active","children","forEach","childId","cloneDeep","activateGraphNode","dfsActivate","searchId","currentId","dependencyMet","search","depMet","parents","keys","filter","key","indexOf","activated","parentId","retG","appendNode","node","head","clonedHead","last","parseHash","hashRoute","routeGraph","recParse","hash","rootId","visitedNodes","child","newG","matches","substrIndex","length","arrayHead","substr","newGraph","buildGraph","IMMUTABLE_GRAPH","listToHashRoute","str","graphToLinkedList","listHead","nextListNode","newHead","logGraph","lastGraph","peek","graphStack","JSON","stringify","push","graphToList","notifyObservers","obsObj","oldGraph","oldListHead","newListHead","missing","nxt","arr","routeId","obs","removed","observerArray","i","inserted","insertOrRemove","insert","dataToUse","isString","Array","win","location","arguments","undefined","window","observers","subscribe","subscriptions","isObject","matchingKeys","sub","noop","unsubscribe","route","event","handler","isFunction","matchingObservers","pull","remove","step","originalHash","pop","history","replaceState","listener","bind","start","addEventListener","stop","removeEventListener","default","create","any","parse","_len","args","_key","apply","array","values","map","val","results","concat","splice","returnArray","subArray","without","newArray","slice"],"mappings":"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","file":"marbles.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Marbles = function Marbles(routingGraph) {\n\t  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\t\n\t  _classCallCheck(this, Marbles);\n\t\n\t  var IMMUTABLE_GRAPH = routingGraph;\n\t  var DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n\t  var DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n\t  var observers = (0, _util.keys)(IMMUTABLE_GRAPH).reduce(function (obj, key) {\n\t    obj[key] = [];\n\t    return obj;\n\t  }, (0, _util.emptyObject)());\n\t  var graphStack = [];\n\t\n\t  // Private methods\n\t  function expandSegment(segment, data) {\n\t    return segment.replace(DYNAMIC_SEGMENT_REGEX, function (segmentKey) {\n\t      return data[segmentKey.replace(':', '')];\n\t    });\n\t  }\n\t\n\t  function extractSegmentData(templateSegment, segmentWithData) {\n\t    var dynamicSegments = templateSegment.match(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')) || [];\n\t    return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce(function (data, value, index) {\n\t      data[dynamicSegments[index].replace(':', '')] = value;\n\t      return (0, _util.assign)((0, _util.emptyObject)(), data);\n\t    }, (0, _util.emptyObject)());\n\t  }\n\t\n\t  function segmentToRegex(segment) {\n\t    // It just got weird\n\t    var regexed = segment.replace(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'), DIGIT_SEGMENT_REGEX.source);\n\t    return new RegExp(regexed);\n\t  }\n\t\n\t  function findListNode(nodeId, list) {\n\t    var next = list;\n\t    while (next) {\n\t      if (next.id === nodeId) {\n\t        return next;\n\t      }\n\t      next = next.next;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function chainData(list, upToNode) {\n\t    var data = (0, _util.emptyObject)();\n\t    var next = list;\n\t    while (next && next !== upToNode) {\n\t      (0, _util.assign)(data, next.data);\n\t      next = next.next;\n\t    }\n\t    return (0, _util.assign)(data, upToNode.data);\n\t  }\n\t\n\t  function graphNodeToListNode(id, graph) {\n\t    var graphNode = graph[id];\n\t    return (0, _util.assign)((0, _util.emptyObject)(), graphNode, {\n\t      id: id,\n\t      segment: expandSegment(graphNode.segment, graphNode.data),\n\t      next: null\n\t    });\n\t  }\n\t\n\t  function deactivateGraphNode(force, nodeId, immutableGraph) {\n\t    var graph = (0, _util.cloneDeep)(immutableGraph);\n\t    function recDeactivate(target, current, g) {\n\t      var curr = g[current];\n\t      if (target === current || curr.dependency === target || force) {\n\t        curr.active = false;\n\t        curr.data = (0, _util.emptyObject)();\n\t      }\n\t      curr.children.forEach(function (childId) {\n\t        return recDeactivate(target, childId, g);\n\t      });\n\t    }\n\t    recDeactivate(nodeId, nodeId, graph);\n\t    return graph;\n\t  }\n\t\n\t  function activateGraphNode(nodeId, data, immutableGraph) {\n\t    var graph = (0, _util.cloneDeep)(immutableGraph);\n\t    var parents = (0, _util.keys)(graph).filter(function (key) {\n\t      return graph[key].children.indexOf(nodeId) !== -1;\n\t    });\n\t    function dfsActivate(searchId, currentId, dependencyMet) {\n\t      var curr = graph[currentId];\n\t      var search = graph[searchId];\n\t      if (currentId === searchId && dependencyMet) {\n\t        search.active = true;\n\t        search.data = data;\n\t        return true;\n\t      } else if (currentId === searchId && !dependencyMet) {\n\t        return false;\n\t      }\n\t      return curr.children.reduce(function (depMet, childId) {\n\t        return dfsActivate(searchId, childId, depMet);\n\t      }, dependencyMet || currentId === search.dependency);\n\t    }\n\t\n\t    var activated = dfsActivate(nodeId, 'root', false);\n\t    if (activated) {\n\t      // deactivate immediate siblings\n\t      return parents.reduce(function (g, parentId) {\n\t        return g[parentId].children.filter(function (id) {\n\t          return id !== nodeId;\n\t        }).reduce(function (retG, childId) {\n\t          return deactivateGraphNode(true, childId, retG);\n\t        }, g);\n\t      }, graph);\n\t    }\n\t    return graph;\n\t  }\n\t\n\t  function appendNode(node, head) {\n\t    var clonedHead = (0, _util.cloneDeep)(head);\n\t    var next = clonedHead;\n\t    var last = void 0;\n\t    var dependencyMet = false;\n\t    while (next) {\n\t      dependencyMet = dependencyMet || next.id === node.dependency;\n\t      last = next;\n\t      next = next.next;\n\t    }\n\t    if (dependencyMet) {\n\t      last.next = (0, _util.cloneDeep)(node);\n\t    }\n\t    return clonedHead;\n\t  }\n\t\n\t  function parseHash(hashRoute, routeGraph) {\n\t    function recParse(hash, rootId, visitedNodes, graph) {\n\t      var root = graph[rootId];\n\t      return root.children.reduce(function (g, childId) {\n\t        var child = graph[childId];\n\t        var newG = g;\n\t        var matches = hash.match(segmentToRegex(child.segment)) || [];\n\t        var substrIndex = matches.index ? matches.index + matches[0].length : 0;\n\t        if (visitedNodes[childId]) {\n\t          return newG;\n\t        }\n\t        visitedNodes[childId] = true;\n\t        if (matches.length > 0 && (graph[child.dependency] || (0, _util.emptyObject)()).active) {\n\t          newG = activateGraphNode(childId, extractSegmentData(child.segment, (0, _util.arrayHead)(matches)), graph);\n\t        }\n\t        return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n\t      }, graph);\n\t    }\n\t    var newGraph = (0, _util.cloneDeep)(routeGraph);\n\t    return recParse(hashRoute, 'root', {}, newGraph);\n\t  }\n\t\n\t  function buildGraph(hash) {\n\t    return parseHash(hash, IMMUTABLE_GRAPH);\n\t  }\n\t\n\t  function listToHashRoute(head) {\n\t    var str = '#';\n\t    var next = head;\n\t    while (next) {\n\t      if (next.segment) {\n\t        str += next.segment + '/';\n\t      }\n\t      next = next.next;\n\t    }\n\t    return str;\n\t  }\n\t\n\t  function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n\t    var root = graph[rootId];\n\t    var nextListNode = graphNodeToListNode(rootId, graph);\n\t    var newHead = root.active ? appendNode(nextListNode, listHead) : (0, _util.cloneDeep)(listHead);\n\t\n\t    return root.children.reduce(function (head, childId) {\n\t      if (visitedNodes[childId]) {\n\t        return head;\n\t      }\n\t      visitedNodes[childId] = true;\n\t      return graphToLinkedList(graph, childId, head, visitedNodes);\n\t    }, newHead);\n\t  }\n\t\n\t  function logGraph(newGraph) {\n\t    var lastGraph = (0, _util.peek)(graphStack);\n\t    if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n\t      graphStack.push(newGraph);\n\t    }\n\t    return newGraph;\n\t  }\n\t\n\t  function graphToList(graph) {\n\t    if (!graph) {\n\t      return null;\n\t    }\n\t    return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), (0, _util.emptyObject)());\n\t  }\n\t\n\t  function notifyObservers(obsObj, oldGraph, newGraph) {\n\t    var oldListHead = graphToList(oldGraph);\n\t    var newListHead = graphToList(newGraph);\n\t    var missing = function () {\n\t      var nxt = oldListHead;\n\t      var arr = [];\n\t      while (nxt) {\n\t        if (!findListNode(nxt.id, newListHead)) {\n\t          arr.push(nxt.id);\n\t        }\n\t        nxt = nxt.next;\n\t      }\n\t      return arr;\n\t    }();\n\t    missing.forEach(function (routeId) {\n\t      obsObj[routeId].forEach(function (obs) {\n\t        obs.removed();\n\t      });\n\t    });\n\t    var next = newListHead;\n\t    while (next) {\n\t      var observerArray = obsObj[next.id];\n\t      for (var i = 0; i < observerArray.length; i++) {\n\t        observerArray[i].inserted(chainData(newListHead, next));\n\t      }\n\t      next = next.next;\n\t    }\n\t  }\n\t\n\t  function insertOrRemove(insert, routeId, data) {\n\t    var dataToUse = data;\n\t    if (!(0, _util.isString)(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n\t      return null;\n\t    }\n\t    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data instanceof Array) {\n\t      dataToUse = (0, _util.emptyObject)();\n\t    }\n\t    var graph = buildGraph(win.location.hash);\n\t    var newGraph = void 0;\n\t    if (insert) {\n\t      newGraph = activateGraphNode(routeId, dataToUse, graph);\n\t    } else {\n\t      newGraph = deactivateGraphNode(false, routeId, graph);\n\t    }\n\t    win.location.hash = listToHashRoute(graphToList(newGraph));\n\t    return this;\n\t  }\n\t  // End private methods\n\t\n\t  // Public methods\n\t  this.subscribe = function subscribe(subscriptions) {\n\t    if (!(0, _util.isObject)(subscriptions)) {\n\t      return false;\n\t    }\n\t    var matchingKeys = (0, _util.keys)(subscriptions).filter(function (key) {\n\t      return !!observers[key];\n\t    });\n\t    if (matchingKeys.length === 0) {\n\t      return false;\n\t    }\n\t    matchingKeys.forEach(function (key) {\n\t      var sub = subscriptions[key];\n\t      observers[key].push({\n\t        inserted: sub.inserted || _util.noop,\n\t        removed: sub.removed || _util.noop\n\t      });\n\t    });\n\t    return true;\n\t  };\n\t  this.unsubscribe = function unsubscribe(route, event, handler) {\n\t    if (!(0, _util.isString)(route) || !(0, _util.isString)(event) || !(0, _util.isFunction)(handler) || !observers[route]) {\n\t      return false;\n\t    }\n\t    var matchingObservers = observers[route].filter(function (obs) {\n\t      return obs[event] === handler;\n\t    });\n\t    return (0, _util.pull)(matchingObservers, observers[route]);\n\t  };\n\t  this.insert = function insert(routeId, data) {\n\t    return insertOrRemove.call(this, true, routeId, data);\n\t  };\n\t  this.remove = function remove(routeId) {\n\t    return insertOrRemove.call(this, false, routeId);\n\t  };\n\t  this.step = function step() {\n\t    var originalHash = win.location.hash;\n\t    var graph = buildGraph(originalHash);\n\t    notifyObservers(observers, graphStack.pop(), graph);\n\t    logGraph(graph);\n\t    win.history.replaceState((0, _util.emptyObject)(), '', listToHashRoute(graphToList(graph)));\n\t    return this;\n\t  };\n\t\n\t  var listener = this.step.bind(this);\n\t  this.start = function start() {\n\t    win.addEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  this.stop = function stop() {\n\t    win.removeEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  // End public methods\n\t};\n\t\n\texports.default = Marbles;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction emptyObject() {\n\t  return Object.create(null);\n\t}\n\t\n\tfunction isObject(any) {\n\t  return (typeof any === 'undefined' ? 'undefined' : _typeof(any)) === 'object' && any !== null && !(any instanceof Array);\n\t}\n\t\n\tfunction isString(any) {\n\t  return typeof any === 'string';\n\t}\n\t\n\tfunction isFunction(any) {\n\t  return typeof any === 'function';\n\t}\n\t\n\tfunction keys(obj) {\n\t  return Object.keys(obj);\n\t}\n\t\n\tfunction cloneDeep(obj) {\n\t  return JSON.parse(JSON.stringify(obj));\n\t}\n\t\n\tfunction assign() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return Object.assign.apply(this, args);\n\t}\n\t\n\tfunction arrayHead(array) {\n\t  if (typeof array === 'undefined' || !(array instanceof Array)) {\n\t    return undefined;\n\t  }\n\t  return array[0];\n\t}\n\t\n\tfunction pull(values, array) {\n\t  return values.map(function (val) {\n\t    var index = array.indexOf(val);\n\t    var results = [];\n\t    while (index !== -1) {\n\t      results = results.concat(array.splice(index, 1));\n\t      index = array.indexOf(val);\n\t    }\n\t    return results;\n\t  }).reduce(function (returnArray, subArray) {\n\t    return returnArray.concat(subArray);\n\t  }, []).reduce(function (returnArray, val) {\n\t    if (returnArray.indexOf(val) !== -1) {\n\t      return returnArray;\n\t    }\n\t    return returnArray.concat(val instanceof Array ? [val] : val);\n\t  }, []);\n\t}\n\t\n\tfunction without(values, array) {\n\t  var newArray = array.slice();\n\t  pull(values, newArray);\n\t  return newArray;\n\t}\n\t\n\tfunction peek(arr) {\n\t  if (!arr || !(arr instanceof Array)) {\n\t    return null;\n\t  }\n\t  return arr[arr.length - 1] || null;\n\t}\n\t\n\tfunction noop() {}\n\t\n\texports.emptyObject = emptyObject;\n\texports.isObject = isObject;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.noop = noop;\n\texports.keys = keys;\n\texports.peek = peek;\n\texports.cloneDeep = cloneDeep;\n\texports.assign = assign;\n\texports.arrayHead = arrayHead;\n\texports.pull = pull;\n\texports.without = without;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// marbles.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap aaec09ae39c8d97f0d60","import {\n  pull,\n  isString,\n  isFunction,\n  emptyObject,\n  noop,\n  keys,\n  cloneDeep,\n  assign,\n  arrayHead,\n  isObject,\n  peek\n} from './util.js';\n\nexport default class Marbles {\n  constructor(routingGraph, win = window) {\n    const IMMUTABLE_GRAPH = routingGraph;\n    const DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n    const DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n    const observers = keys(IMMUTABLE_GRAPH).reduce((obj, key) => {\n      obj[key] = [];\n      return obj;\n    }, emptyObject());\n    const graphStack = [];\n\n    // Private methods\n    function expandSegment(segment, data) {\n      return segment.replace(\n        DYNAMIC_SEGMENT_REGEX,\n        segmentKey => data[segmentKey.replace(':', '')]\n      );\n    }\n\n    function extractSegmentData(templateSegment, segmentWithData) {\n      const dynamicSegments = templateSegment.match(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')\n      ) || [];\n      return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce((data, value, index) => {\n        data[dynamicSegments[index].replace(':', '')] = value;\n        return assign(emptyObject(), data);\n      },\n        emptyObject()\n      );\n    }\n\n    function segmentToRegex(segment) {\n      // It just got weird\n      const regexed = segment.replace(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'),\n        DIGIT_SEGMENT_REGEX.source\n      );\n      return new RegExp(regexed);\n    }\n\n    function findListNode(nodeId, list) {\n      let next = list;\n      while (next) {\n        if (next.id === nodeId) {\n          return next;\n        }\n        next = next.next;\n      }\n      return null;\n    }\n\n    function chainData(list, upToNode) {\n      const data = emptyObject();\n      let next = list;\n      while (next && next !== upToNode) {\n        assign(data, next.data);\n        next = next.next;\n      }\n      return assign(data, upToNode.data);\n    }\n\n    function graphNodeToListNode(id, graph) {\n      const graphNode = graph[id];\n      return assign(emptyObject(), graphNode, {\n        id,\n        segment: expandSegment(graphNode.segment, graphNode.data),\n        next: null,\n      });\n    }\n\n    function deactivateGraphNode(force, nodeId, immutableGraph) {\n      const graph = cloneDeep(immutableGraph);\n      function recDeactivate(target, current, g) {\n        const curr = g[current];\n        if (target === current || curr.dependency === target || force) {\n          curr.active = false;\n          curr.data = emptyObject();\n        }\n        curr.children.forEach(childId => recDeactivate(target, childId, g));\n      }\n      recDeactivate(nodeId, nodeId, graph);\n      return graph;\n    }\n\n    function activateGraphNode(nodeId, data, immutableGraph) {\n      const graph = cloneDeep(immutableGraph);\n      const parents = keys(graph).filter(key => graph[key].children.indexOf(nodeId) !== -1);\n      function dfsActivate(searchId, currentId, dependencyMet) {\n        const curr = graph[currentId];\n        const search = graph[searchId];\n        if (currentId === searchId && dependencyMet) {\n          search.active = true;\n          search.data = data;\n          return true;\n        }\n        else if (currentId === searchId && !dependencyMet) {\n          return false;\n        }\n        return curr.children.reduce(\n          (depMet, childId) => dfsActivate(searchId, childId, depMet),\n          dependencyMet || currentId === search.dependency\n        );\n      }\n\n      const activated = dfsActivate(nodeId, 'root', false);\n      if (activated) {\n        // deactivate immediate siblings\n        return parents.reduce((g, parentId) => {\n          return g[parentId].children.filter(id => id !== nodeId).reduce((retG, childId) => {\n            return deactivateGraphNode(true, childId, retG);\n          }, g);\n        }, graph);\n      }\n      return graph;\n    }\n\n    function appendNode(node, head) {\n      const clonedHead = cloneDeep(head);\n      let next = clonedHead;\n      let last;\n      let dependencyMet = false;\n      while (next) {\n        dependencyMet = dependencyMet || next.id === node.dependency;\n        last = next;\n        next = next.next;\n      }\n      if (dependencyMet) {\n        last.next = cloneDeep(node);\n      }\n      return clonedHead;\n    }\n\n    function parseHash(hashRoute, routeGraph) {\n      function recParse(hash, rootId, visitedNodes, graph) {\n        const root = graph[rootId];\n        return root.children.reduce((g, childId) => {\n          const child = graph[childId];\n          let newG = g;\n          const matches = hash.match(segmentToRegex(child.segment)) || [];\n          const substrIndex = matches.index ? matches.index + matches[0].length : 0;\n          if (visitedNodes[childId]) {\n            return newG;\n          }\n          visitedNodes[childId] = true;\n          if (matches.length > 0 && (graph[child.dependency] || emptyObject()).active) {\n            newG = activateGraphNode(\n              childId,\n              extractSegmentData(child.segment, arrayHead(matches)),\n              graph\n            );\n          }\n          return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n        }, graph);\n      }\n      const newGraph = cloneDeep(routeGraph);\n      return recParse(hashRoute, 'root', {}, newGraph);\n    }\n\n    function buildGraph(hash) {\n      return parseHash(hash, IMMUTABLE_GRAPH);\n    }\n\n    function listToHashRoute(head) {\n      let str = '#';\n      let next = head;\n      while (next) {\n        if (next.segment) {\n          str += `${next.segment}/`;\n        }\n        next = next.next;\n      }\n      return str;\n    }\n\n    function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n      const root = graph[rootId];\n      const nextListNode = graphNodeToListNode(rootId, graph);\n      const newHead = root.active ? appendNode(nextListNode, listHead) : cloneDeep(listHead);\n\n      return root.children.reduce(\n        (head, childId) => {\n          if (visitedNodes[childId]) {\n            return head;\n          }\n          visitedNodes[childId] = true;\n          return graphToLinkedList(graph, childId, head, visitedNodes);\n        },\n        newHead\n      );\n    }\n\n    function logGraph(newGraph) {\n      const lastGraph = peek(graphStack);\n      if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n        graphStack.push(newGraph);\n      }\n      return newGraph;\n    }\n\n    function graphToList(graph) {\n      if (!graph) {\n        return null;\n      }\n      return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), emptyObject());\n    }\n\n    function notifyObservers(obsObj, oldGraph, newGraph) {\n      const oldListHead = graphToList(oldGraph);\n      const newListHead = graphToList(newGraph);\n      const missing = (() => {\n        let nxt = oldListHead;\n        const arr = [];\n        while (nxt) {\n          if (!findListNode(nxt.id, newListHead)) {\n            arr.push(nxt.id);\n          }\n          nxt = nxt.next;\n        }\n        return arr;\n      })();\n      missing.forEach((routeId) => {\n        obsObj[routeId].forEach((obs) => {\n          obs.removed();\n        });\n      });\n      let next = newListHead;\n      while (next) {\n        const observerArray = obsObj[next.id];\n        for (let i = 0; i < observerArray.length; i++) {\n          observerArray[i].inserted(chainData(newListHead, next));\n        }\n        next = next.next;\n      }\n    }\n\n    function insertOrRemove(insert, routeId, data) {\n      let dataToUse = data;\n      if (!isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n        return null;\n      }\n      if (data === null || typeof data !== 'object' || data instanceof Array) {\n        dataToUse = emptyObject();\n      }\n      const graph = buildGraph(win.location.hash);\n      let newGraph;\n      if (insert) {\n        newGraph = activateGraphNode(routeId, dataToUse, graph);\n      }\n      else {\n        newGraph = deactivateGraphNode(false, routeId, graph);\n      }\n      win.location.hash = listToHashRoute(graphToList(newGraph));\n      return this;\n    }\n    // End private methods\n\n    // Public methods\n    this.subscribe = function subscribe(subscriptions) {\n      if (!isObject(subscriptions)) {\n        return false;\n      }\n      const matchingKeys = keys(subscriptions).filter(key => !!observers[key]);\n      if (matchingKeys.length === 0) {\n        return false;\n      }\n      matchingKeys.forEach(key => {\n        const sub = subscriptions[key];\n        observers[key].push({\n          inserted: sub.inserted || noop,\n          removed: sub.removed || noop,\n        });\n      });\n      return true;\n    };\n    this.unsubscribe = function unsubscribe(route, event, handler) {\n      if (!isString(route) || !isString(event) || !isFunction(handler) || !observers[route]) {\n        return false;\n      }\n      const matchingObservers = observers[route].filter((obs) => obs[event] === handler);\n      return pull(matchingObservers, observers[route]);\n    };\n    this.insert = function insert(routeId, data) {\n      return insertOrRemove.call(this, true, routeId, data);\n    };\n    this.remove = function remove(routeId) {\n      return insertOrRemove.call(this, false, routeId);\n    };\n    this.step = function step() {\n      const originalHash = win.location.hash;\n      const graph = buildGraph(originalHash);\n      notifyObservers(observers, graphStack.pop(), graph);\n      logGraph(graph);\n      win.history.replaceState(emptyObject(), '', listToHashRoute(graphToList(graph)));\n      return this;\n    };\n\n    const listener = this.step.bind(this);\n    this.start = function start() {\n      win.addEventListener('hashchange', listener);\n      return this;\n    };\n    this.stop = function stop() {\n      win.removeEventListener('hashchange', listener);\n      return this;\n    };\n    // End public methods\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/marbles.js","function emptyObject() {\n  return Object.create(null);\n}\n\nfunction isObject(any) {\n  return typeof any === 'object' && any !== null && !(any instanceof Array);\n}\n\nfunction isString(any) {\n  return typeof any === 'string';\n}\n\nfunction isFunction(any) {\n  return typeof any === 'function';\n}\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction assign(...args) {\n  return Object.assign.apply(this, args);\n}\n\nfunction arrayHead(array) {\n  if (typeof array === 'undefined' || !(array instanceof Array)) {\n    return undefined;\n  }\n  return array[0];\n}\n\nfunction pull(values, array) {\n  return values.map((val) => {\n    let index = array.indexOf(val);\n    let results = [];\n    while (index !== -1) {\n      results = results.concat(array.splice(index, 1));\n      index = array.indexOf(val);\n    }\n    return results;\n  })\n  .reduce((returnArray, subArray) => returnArray.concat(subArray), [])\n  .reduce((returnArray, val) => {\n    if (returnArray.indexOf(val) !== -1) {\n      return returnArray;\n    }\n    return returnArray.concat(val instanceof Array ? [val] : val);\n  }, []);\n}\n\nfunction without(values, array) {\n  const newArray = array.slice();\n  pull(values, newArray);\n  return newArray;\n}\n\nfunction peek(arr) {\n  if (!arr || !(arr instanceof Array)) {\n    return null;\n  }\n  return arr[arr.length-1] || null;\n}\n\nfunction noop() {}\n\nexport {\n  emptyObject,\n  isObject,\n  isFunction,\n  isString,\n  noop,\n  keys,\n  peek,\n  cloneDeep,\n  assign,\n  arrayHead,\n  pull,\n  without\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js"],"sourceRoot":""}