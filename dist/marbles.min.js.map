{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marbles.min.js","webpack:///webpack/bootstrap 10961f07e26d9b87cb0e","webpack:///./src/marbles.js","webpack:///./src/util.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_util","util","Marbles","routingGraph","expandSegment","segment","data","replace","DYNAMIC_SEGMENT_REGEX","segmentKey","extractSegmentData","templateSegment","segmentWithData","dynamicSegments","match","RegExp","source","DIGIT_SEGMENT_REGEX","reduce","index","assign","emptyObject","segmentToRegex","regexed","findListNode","nodeId","list","next","chainData","upToNode","stop","isObject","graphNodeToListNode","graph","graphNode","deactivateGraphNode","force","immutableGraph","recDeactivate","target","current","g","curr","dependency","active","children","forEach","childId","cloneDeep","activateGraphNode","dfsActivate","searchId","currentId","dependencyMet","search","depMet","parents","keys","filter","indexOf","activated","parentId","retG","appendNode","node","head","clonedHead","last","parseHash","hashRoute","routeGraph","recParse","hash","rootId","visitedNodes","child","newG","matches","substrIndex","length","arrayHead","substr","newGraph","buildGraph","IMMUTABLE_GRAPH","listToHashRoute","listReduce","graphToLinkedList","listHead","nextListNode","newHead","logGraph","lastGraph","peek","graphStack","JSON","stringify","push","graphToList","listDiff","from","against","arr","concat","notifyObservers","obsObj","oldGraph","oldListHead","newListHead","removed","insertedNodes","_ref","obs","inserted","insertOrRemove","insert","routeId","dataToUse","isString","Array","win","location","arguments","undefined","window","observers","subscribe","subscriptions","matchingKeys","sub","noop","unsubscribe","route","event","handler","isFunction","matchingObservers","pull","remove","getData","step","originalHash","pop","history","replaceState","listener","bind","start","addEventListener","removeEventListener","create","any","isArray","parse","_len","args","_key","apply","array","values","map","val","results","splice","returnArray","subArray","without","newArray","slice","isList","listish","assertList","listForEach","i","listMap","newNodes","reduceRight","tail","reducer","accumulator","foldl","f","a","batchAsyncActions","fns","callback","resolvedCount","fn","result"],"mappings":"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","file":"marbles.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar util = _interopRequireWildcard(_util);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Marbles = function Marbles(routingGraph) {\n\t  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\t\n\t  _classCallCheck(this, Marbles);\n\t\n\t  var IMMUTABLE_GRAPH = routingGraph;\n\t  var DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n\t  var DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n\t  var observers = util.keys(IMMUTABLE_GRAPH).reduce(function (obj, key) {\n\t    obj[key] = [];\n\t    return obj;\n\t  }, util.emptyObject());\n\t  var graphStack = [];\n\t\n\t  // Private methods\n\t  function expandSegment(segment, data) {\n\t    return segment.replace(DYNAMIC_SEGMENT_REGEX, function (segmentKey) {\n\t      return data[segmentKey.replace(':', '')];\n\t    });\n\t  }\n\t\n\t  function extractSegmentData(templateSegment, segmentWithData) {\n\t    var dynamicSegments = templateSegment.match(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')) || [];\n\t    return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce(function (data, value, index) {\n\t      data[dynamicSegments[index].replace(':', '')] = value;\n\t      return util.assign(util.emptyObject(), data);\n\t    }, util.emptyObject());\n\t  }\n\t\n\t  function segmentToRegex(segment) {\n\t    // It just got weird\n\t    var regexed = segment.replace(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'), DIGIT_SEGMENT_REGEX.source);\n\t    return new RegExp(regexed);\n\t  }\n\t\n\t  function findListNode(nodeId, list) {\n\t    var next = list;\n\t    while (next) {\n\t      if (next.id === nodeId) {\n\t        return next;\n\t      }\n\t      next = next.next;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function chainData(list, upToNode) {\n\t    var data = util.emptyObject();\n\t    var stop = util.isObject(upToNode) ? upToNode : { data: {} };\n\t    var next = list;\n\t    while (next && next !== stop) {\n\t      util.assign(data, next.data);\n\t      next = next.next;\n\t    }\n\t    return util.assign(data, stop.data);\n\t  }\n\t\n\t  function graphNodeToListNode(id, graph) {\n\t    var graphNode = graph[id];\n\t    return util.assign(util.emptyObject(), graphNode, {\n\t      id: id,\n\t      segment: expandSegment(graphNode.segment, graphNode.data),\n\t      next: null\n\t    });\n\t  }\n\t\n\t  function deactivateGraphNode(force, nodeId, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    function recDeactivate(target, current, g) {\n\t      var curr = g[current];\n\t      if (target === current || curr.dependency === target || force) {\n\t        curr.active = false;\n\t        curr.data = util.emptyObject();\n\t      }\n\t      curr.children.forEach(function (childId) {\n\t        return recDeactivate(target, childId, g);\n\t      });\n\t    }\n\t    recDeactivate(nodeId, nodeId, graph);\n\t    return graph;\n\t  }\n\t\n\t  function activateGraphNode(nodeId, data, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    var parents = util.keys(graph).filter(function (key) {\n\t      return graph[key].children.indexOf(nodeId) !== -1;\n\t    });\n\t    function dfsActivate(searchId, currentId, dependencyMet) {\n\t      var curr = graph[currentId];\n\t      var search = graph[searchId];\n\t      if (currentId === searchId && dependencyMet) {\n\t        search.active = true;\n\t        search.data = data;\n\t        return true;\n\t      } else if (currentId === searchId && !dependencyMet) {\n\t        return false;\n\t      }\n\t      return curr.children.reduce(function (depMet, childId) {\n\t        return dfsActivate(searchId, childId, depMet);\n\t      }, dependencyMet || currentId === search.dependency);\n\t    }\n\t\n\t    var activated = dfsActivate(nodeId, 'root', false);\n\t    if (activated) {\n\t      // deactivate immediate siblings\n\t      return parents.reduce(function (g, parentId) {\n\t        return g[parentId].children.filter(function (id) {\n\t          return id !== nodeId;\n\t        }).reduce(function (retG, childId) {\n\t          return deactivateGraphNode(true, childId, retG);\n\t        }, g);\n\t      }, graph);\n\t    }\n\t    return graph;\n\t  }\n\t\n\t  function appendNode(node, head) {\n\t    var clonedHead = util.cloneDeep(head);\n\t    var next = clonedHead;\n\t    var last = void 0;\n\t    var dependencyMet = false;\n\t    while (next) {\n\t      dependencyMet = dependencyMet || next.id === node.dependency;\n\t      last = next;\n\t      next = next.next;\n\t    }\n\t    if (dependencyMet) {\n\t      last.next = util.cloneDeep(node);\n\t    }\n\t    return clonedHead;\n\t  }\n\t\n\t  function parseHash(hashRoute, routeGraph) {\n\t    function recParse(hash, rootId, visitedNodes, graph) {\n\t      var root = graph[rootId];\n\t      return root.children.reduce(function (g, childId) {\n\t        var child = graph[childId];\n\t        var newG = g;\n\t        var matches = hash.match(segmentToRegex(child.segment)) || [];\n\t        var substrIndex = matches.index ? matches.index + matches[0].length : 0;\n\t        if (visitedNodes[childId]) {\n\t          return newG;\n\t        }\n\t        visitedNodes[childId] = true;\n\t        if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\n\t          newG = activateGraphNode(childId, extractSegmentData(child.segment, util.arrayHead(matches)), graph);\n\t        }\n\t        return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n\t      }, graph);\n\t    }\n\t    var newGraph = util.cloneDeep(routeGraph);\n\t    return recParse(hashRoute, 'root', {}, newGraph);\n\t  }\n\t\n\t  function buildGraph(hash) {\n\t    return parseHash(hash, IMMUTABLE_GRAPH);\n\t  }\n\t\n\t  function listToHashRoute(head) {\n\t    return util.listReduce(function (hash, node) {\n\t      if (node.segment) {\n\t        return '' + hash + node.segment + '/';\n\t      }\n\t      return hash;\n\t    }, '#', head);\n\t  }\n\t\n\t  function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n\t    var root = graph[rootId];\n\t    var nextListNode = graphNodeToListNode(rootId, graph);\n\t    var newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\n\t\n\t    return root.children.reduce(function (head, childId) {\n\t      if (visitedNodes[childId]) {\n\t        return head;\n\t      }\n\t      visitedNodes[childId] = true;\n\t      return graphToLinkedList(graph, childId, head, visitedNodes);\n\t    }, newHead);\n\t  }\n\t\n\t  function logGraph(newGraph) {\n\t    var lastGraph = util.peek(graphStack);\n\t    if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n\t      graphStack.push(newGraph);\n\t    }\n\t    return newGraph;\n\t  }\n\t\n\t  function graphToList(graph) {\n\t    if (!graph) {\n\t      return null;\n\t    }\n\t    return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), util.emptyObject());\n\t  }\n\t\n\t  function listDiff(from, against) {\n\t    return util.listReduce(function (arr, node) {\n\t      if (!findListNode(node.id, against)) {\n\t        return arr.concat(node);\n\t      }\n\t      return arr;\n\t    }, [], from);\n\t  }\n\t\n\t  function notifyObservers(obsObj, oldGraph, newGraph) {\n\t    var oldListHead = graphToList(oldGraph);\n\t    var newListHead = graphToList(newGraph);\n\t    var removed = listDiff(oldListHead, newListHead);\n\t    var insertedNodes = listDiff(newListHead, oldListHead);\n\t    removed.forEach(function (_ref) {\n\t      var id = _ref.id;\n\t\n\t      obsObj[id].forEach(function (obs) {\n\t        obs.removed();\n\t      });\n\t    });\n\t    insertedNodes.forEach(function (node) {\n\t      obsObj[node.id].forEach(function (obs) {\n\t        obs.inserted(chainData(newListHead, node));\n\t      });\n\t    });\n\t  }\n\t\n\t  function insertOrRemove(insert, routeId, data) {\n\t    var dataToUse = data;\n\t    if (!util.isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n\t      return null;\n\t    }\n\t    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data instanceof Array) {\n\t      dataToUse = util.emptyObject();\n\t    }\n\t    var graph = buildGraph(win.location.hash);\n\t    var newGraph = void 0;\n\t    if (insert) {\n\t      newGraph = activateGraphNode(routeId, dataToUse, graph);\n\t    } else {\n\t      newGraph = deactivateGraphNode(false, routeId, graph);\n\t    }\n\t    win.location.hash = listToHashRoute(graphToList(newGraph));\n\t    return this;\n\t  }\n\t  // End private methods\n\t\n\t  // Public methods\n\t  this.subscribe = function subscribe(subscriptions) {\n\t    if (!util.isObject(subscriptions)) {\n\t      return false;\n\t    }\n\t    var matchingKeys = util.keys(subscriptions).filter(function (key) {\n\t      return !!observers[key];\n\t    });\n\t    if (matchingKeys.length === 0) {\n\t      return false;\n\t    }\n\t    matchingKeys.forEach(function (key) {\n\t      var sub = subscriptions[key];\n\t      observers[key].push({\n\t        inserted: sub.inserted || util.noop,\n\t        removed: sub.removed || util.noop\n\t      });\n\t    });\n\t    return true;\n\t  };\n\t  this.unsubscribe = function unsubscribe(route, event, handler) {\n\t    if (!util.isString(route) || !util.isString(event) || !util.isFunction(handler) || !observers[route]) {\n\t      return false;\n\t    }\n\t    var matchingObservers = observers[route].filter(function (obs) {\n\t      return obs[event] === handler;\n\t    });\n\t    return util.pull(matchingObservers, observers[route]);\n\t  };\n\t  this.insert = function insert(routeId, data) {\n\t    return insertOrRemove.call(this, true, routeId, data);\n\t  };\n\t  this.remove = function remove(routeId) {\n\t    return insertOrRemove.call(this, false, routeId);\n\t  };\n\t  this.getData = function getData() {\n\t    return chainData(graphToList(buildGraph(win.location.hash)));\n\t  };\n\t  this.step = function step() {\n\t    var originalHash = win.location.hash;\n\t    var graph = buildGraph(originalHash);\n\t    notifyObservers(observers, graphStack.pop(), graph);\n\t    logGraph(graph);\n\t    win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(graph)));\n\t    return this;\n\t  };\n\t\n\t  var listener = this.step.bind(this);\n\t  this.start = function start() {\n\t    win.addEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  this.stop = function stop() {\n\t    win.removeEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  // End public methods\n\t};\n\t\n\texports.default = Marbles;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction emptyObject() {\n\t  return Object.create(null);\n\t}\n\t\n\tfunction isObject(any) {\n\t  return (typeof any === 'undefined' ? 'undefined' : _typeof(any)) === 'object' && any !== null && !(any instanceof Array);\n\t}\n\t\n\tfunction isArray(any) {\n\t  return any instanceof Array;\n\t}\n\t\n\tfunction isString(any) {\n\t  return typeof any === 'string';\n\t}\n\t\n\tfunction isFunction(any) {\n\t  return typeof any === 'function';\n\t}\n\t\n\tfunction keys(obj) {\n\t  return Object.keys(obj);\n\t}\n\t\n\tfunction cloneDeep(obj) {\n\t  return JSON.parse(JSON.stringify(obj));\n\t}\n\t\n\tfunction assign() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return Object.assign.apply(this, args);\n\t}\n\t\n\tfunction arrayHead(array) {\n\t  if (typeof array === 'undefined' || !(array instanceof Array)) {\n\t    return undefined;\n\t  }\n\t  return array[0];\n\t}\n\t\n\tfunction pull(values, array) {\n\t  return values.map(function (val) {\n\t    var index = array.indexOf(val);\n\t    var results = [];\n\t    while (index !== -1) {\n\t      results = results.concat(array.splice(index, 1));\n\t      index = array.indexOf(val);\n\t    }\n\t    return results;\n\t  }).reduce(function (returnArray, subArray) {\n\t    return returnArray.concat(subArray);\n\t  }, []).reduce(function (returnArray, val) {\n\t    if (returnArray.indexOf(val) !== -1) {\n\t      return returnArray;\n\t    }\n\t    return returnArray.concat(val instanceof Array ? [val] : val);\n\t  }, []);\n\t}\n\t\n\tfunction without(values, array) {\n\t  var newArray = array.slice();\n\t  pull(values, newArray);\n\t  return newArray;\n\t}\n\t\n\tfunction peek(arr) {\n\t  if (!arr || !(arr instanceof Array)) {\n\t    return null;\n\t  }\n\t  return arr[arr.length - 1] || null;\n\t}\n\t\n\tfunction noop() {}\n\t\n\tfunction isList(listish) {\n\t  return listish === null || isObject(listish) && _typeof(listish.next) === 'object';\n\t}\n\t\n\tfunction assertList(list) {\n\t  if (!isList(list)) {\n\t    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\n\t  }\n\t}\n\t\n\tfunction listForEach(iterator, list) {\n\t  assertList(list);\n\t  var next = list;\n\t  var i = 0;\n\t  while (next) {\n\t    iterator(next, i);\n\t    next = next.next;\n\t    i = i + 1;\n\t  }\n\t}\n\t\n\tfunction listMap(iterator, list) {\n\t  var newNodes = [];\n\t  listForEach(function (node, index) {\n\t    newNodes.push(iterator(node, index));\n\t  }, list);\n\t  return newNodes.reduceRight(function (tail, node) {\n\t    return assign({}, node, {\n\t      next: tail\n\t    });\n\t  }, null);\n\t}\n\t\n\tfunction listReduce(reducer, accumulator, list) {\n\t  return function foldl(f, a, head, i) {\n\t    if (head === null) {\n\t      return a;\n\t    }\n\t    assertList(head);\n\t    return foldl(f, f(a, head, i), head.next, i + 1);\n\t  }(reducer, accumulator, list, 0);\n\t}\n\t\n\tfunction batchAsyncActions(fns, callback) {\n\t  if (!isArray(fns)) {\n\t    throw new TypeError('batchAsyncResults() expects an array of functions as the first parameter.');\n\t  }\n\t  var resolvedCount = 0;\n\t  var results = [];\n\t  fns.forEach(function (fn) {\n\t    fn(function (result) {\n\t      resolvedCount += 1;\n\t      results.push(result);\n\t      if (resolvedCount === fns.length) {\n\t        callback(results);\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\texports.emptyObject = emptyObject;\n\texports.isArray = isArray;\n\texports.isObject = isObject;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isList = isList;\n\texports.listForEach = listForEach;\n\texports.listMap = listMap;\n\texports.listReduce = listReduce;\n\texports.batchAsyncActions = batchAsyncActions;\n\texports.noop = noop;\n\texports.keys = keys;\n\texports.peek = peek;\n\texports.cloneDeep = cloneDeep;\n\texports.assign = assign;\n\texports.arrayHead = arrayHead;\n\texports.pull = pull;\n\texports.without = without;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// marbles.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 10961f07e26d9b87cb0e","import * as util from './util.js';\n\nexport default class Marbles {\n  constructor(routingGraph, win = window) {\n    const IMMUTABLE_GRAPH = routingGraph;\n    const DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n    const DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n    const observers = util.keys(IMMUTABLE_GRAPH).reduce((obj, key) => {\n      obj[key] = [];\n      return obj;\n    }, util.emptyObject());\n    const graphStack = [];\n\n    // Private methods\n    function expandSegment(segment, data) {\n      return segment.replace(\n        DYNAMIC_SEGMENT_REGEX,\n        segmentKey => data[segmentKey.replace(':', '')]\n      );\n    }\n\n    function extractSegmentData(templateSegment, segmentWithData) {\n      const dynamicSegments = templateSegment.match(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')\n      ) || [];\n      return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce((data, value, index) => {\n        data[dynamicSegments[index].replace(':', '')] = value;\n        return util.assign(util.emptyObject(), data);\n      },\n        util.emptyObject()\n      );\n    }\n\n    function segmentToRegex(segment) {\n      // It just got weird\n      const regexed = segment.replace(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'),\n        DIGIT_SEGMENT_REGEX.source\n      );\n      return new RegExp(regexed);\n    }\n\n    function findListNode(nodeId, list) {\n      let next = list;\n      while (next) {\n        if (next.id === nodeId) {\n          return next;\n        }\n        next = next.next;\n      }\n      return null;\n    }\n\n    function chainData(list, upToNode) {\n      const data = util.emptyObject();\n      const stop = util.isObject(upToNode) ? upToNode : { data: {} };\n      let next = list;\n      while (next && next !== stop) {\n        util.assign(data, next.data);\n        next = next.next;\n      }\n      return util.assign(data, stop.data);\n    }\n\n    function graphNodeToListNode(id, graph) {\n      const graphNode = graph[id];\n      return util.assign(util.emptyObject(), graphNode, {\n        id,\n        segment: expandSegment(graphNode.segment, graphNode.data),\n        next: null,\n      });\n    }\n\n    function deactivateGraphNode(force, nodeId, immutableGraph) {\n      const graph = util.cloneDeep(immutableGraph);\n      function recDeactivate(target, current, g) {\n        const curr = g[current];\n        if (target === current || curr.dependency === target || force) {\n          curr.active = false;\n          curr.data = util.emptyObject();\n        }\n        curr.children.forEach(childId => recDeactivate(target, childId, g));\n      }\n      recDeactivate(nodeId, nodeId, graph);\n      return graph;\n    }\n\n    function activateGraphNode(nodeId, data, immutableGraph) {\n      const graph = util.cloneDeep(immutableGraph);\n      const parents = util.keys(graph).filter(key => graph[key].children.indexOf(nodeId) !== -1);\n      function dfsActivate(searchId, currentId, dependencyMet) {\n        const curr = graph[currentId];\n        const search = graph[searchId];\n        if (currentId === searchId && dependencyMet) {\n          search.active = true;\n          search.data = data;\n          return true;\n        }\n        else if (currentId === searchId && !dependencyMet) {\n          return false;\n        }\n        return curr.children.reduce(\n          (depMet, childId) => dfsActivate(searchId, childId, depMet),\n          dependencyMet || currentId === search.dependency\n        );\n      }\n\n      const activated = dfsActivate(nodeId, 'root', false);\n      if (activated) {\n        // deactivate immediate siblings\n        return parents.reduce((g, parentId) =>\n          g[parentId].children.filter(id => id !== nodeId).reduce((retG, childId) =>\n            deactivateGraphNode(true, childId, retG),\n            g),\n          graph);\n      }\n      return graph;\n    }\n\n    function appendNode(node, head) {\n      const clonedHead = util.cloneDeep(head);\n      let next = clonedHead;\n      let last;\n      let dependencyMet = false;\n      while (next) {\n        dependencyMet = dependencyMet || next.id === node.dependency;\n        last = next;\n        next = next.next;\n      }\n      if (dependencyMet) {\n        last.next = util.cloneDeep(node);\n      }\n      return clonedHead;\n    }\n\n    function parseHash(hashRoute, routeGraph) {\n      function recParse(hash, rootId, visitedNodes, graph) {\n        const root = graph[rootId];\n        return root.children.reduce((g, childId) => {\n          const child = graph[childId];\n          let newG = g;\n          const matches = hash.match(segmentToRegex(child.segment)) || [];\n          const substrIndex = matches.index ? matches.index + matches[0].length : 0;\n          if (visitedNodes[childId]) {\n            return newG;\n          }\n          visitedNodes[childId] = true;\n          if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\n            newG = activateGraphNode(\n              childId,\n              extractSegmentData(child.segment, util.arrayHead(matches)),\n              graph\n            );\n          }\n          return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n        }, graph);\n      }\n      const newGraph = util.cloneDeep(routeGraph);\n      return recParse(hashRoute, 'root', {}, newGraph);\n    }\n\n    function buildGraph(hash) {\n      return parseHash(hash, IMMUTABLE_GRAPH);\n    }\n\n    function listToHashRoute(head) {\n      return util.listReduce((hash, node) => {\n        if (node.segment) {\n          return `${hash}${node.segment}/`;\n        }\n        return hash;\n      }, '#', head);\n    }\n\n    function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n      const root = graph[rootId];\n      const nextListNode = graphNodeToListNode(rootId, graph);\n      const newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\n\n      return root.children.reduce(\n        (head, childId) => {\n          if (visitedNodes[childId]) {\n            return head;\n          }\n          visitedNodes[childId] = true;\n          return graphToLinkedList(graph, childId, head, visitedNodes);\n        },\n        newHead\n      );\n    }\n\n    function logGraph(newGraph) {\n      const lastGraph = util.peek(graphStack);\n      if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n        graphStack.push(newGraph);\n      }\n      return newGraph;\n    }\n\n    function graphToList(graph) {\n      if (!graph) {\n        return null;\n      }\n      return graphToLinkedList(\n        graph,\n        'root',\n        graphNodeToListNode('root', graph),\n        util.emptyObject()\n      );\n    }\n\n    function listDiff(from, against) {\n      return util.listReduce((arr, node) => {\n        if (!findListNode(node.id, against)) {\n          return arr.concat(node);\n        }\n        return arr;\n      }, [], from);\n    }\n\n    function notifyObservers(obsObj, oldGraph, newGraph) {\n      const oldListHead = graphToList(oldGraph);\n      const newListHead = graphToList(newGraph);\n      const removed = listDiff(oldListHead, newListHead);\n      const insertedNodes = listDiff(newListHead, oldListHead);\n      removed.forEach(({ id }) => {\n        obsObj[id].forEach((obs) => {\n          obs.removed();\n        });\n      });\n      insertedNodes.forEach((node) => {\n        obsObj[node.id].forEach((obs) => {\n          obs.inserted(chainData(newListHead, node));\n        });\n      });\n    }\n\n    function insertOrRemove(insert, routeId, data) {\n      let dataToUse = data;\n      if (!util.isString(routeId) || !IMMUTABLE_GRAPH[routeId]) {\n        return null;\n      }\n      if (data === null || typeof data !== 'object' || data instanceof Array) {\n        dataToUse = util.emptyObject();\n      }\n      const graph = buildGraph(win.location.hash);\n      let newGraph;\n      if (insert) {\n        newGraph = activateGraphNode(routeId, dataToUse, graph);\n      }\n      else {\n        newGraph = deactivateGraphNode(false, routeId, graph);\n      }\n      win.location.hash = listToHashRoute(graphToList(newGraph));\n      return this;\n    }\n    // End private methods\n\n    // Public methods\n    this.subscribe = function subscribe(subscriptions) {\n      if (!util.isObject(subscriptions)) {\n        return false;\n      }\n      const matchingKeys = util.keys(subscriptions).filter(key => !!observers[key]);\n      if (matchingKeys.length === 0) {\n        return false;\n      }\n      matchingKeys.forEach(key => {\n        const sub = subscriptions[key];\n        observers[key].push({\n          inserted: sub.inserted || util.noop,\n          removed: sub.removed || util.noop,\n        });\n      });\n      return true;\n    };\n    this.unsubscribe = function unsubscribe(route, event, handler) {\n      if (\n        !util.isString(route) ||\n        !util.isString(event) ||\n        !util.isFunction(handler) ||\n        !observers[route]\n      ) {\n        return false;\n      }\n      const matchingObservers = observers[route].filter((obs) => obs[event] === handler);\n      return util.pull(matchingObservers, observers[route]);\n    };\n    this.insert = function insert(routeId, data) {\n      return insertOrRemove.call(this, true, routeId, data);\n    };\n    this.remove = function remove(routeId) {\n      return insertOrRemove.call(this, false, routeId);\n    };\n    this.getData = function getData() {\n      return chainData(graphToList(buildGraph(win.location.hash)));\n    };\n    this.step = function step() {\n      const originalHash = win.location.hash;\n      const graph = buildGraph(originalHash);\n      notifyObservers(observers, graphStack.pop(), graph);\n      logGraph(graph);\n      win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(graph)));\n      return this;\n    };\n\n    const listener = this.step.bind(this);\n    this.start = function start() {\n      win.addEventListener('hashchange', listener);\n      return this;\n    };\n    this.stop = function stop() {\n      win.removeEventListener('hashchange', listener);\n      return this;\n    };\n    // End public methods\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/marbles.js","function emptyObject() {\n  return Object.create(null);\n}\n\nfunction isObject(any) {\n  return typeof any === 'object' && any !== null && !(any instanceof Array);\n}\n\nfunction isArray(any) {\n  return any instanceof Array;\n}\n\nfunction isString(any) {\n  return typeof any === 'string';\n}\n\nfunction isFunction(any) {\n  return typeof any === 'function';\n}\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction assign(...args) {\n  return Object.assign.apply(this, args);\n}\n\nfunction arrayHead(array) {\n  if (typeof array === 'undefined' || !(array instanceof Array)) {\n    return undefined;\n  }\n  return array[0];\n}\n\nfunction pull(values, array) {\n  return values.map((val) => {\n    let index = array.indexOf(val);\n    let results = [];\n    while (index !== -1) {\n      results = results.concat(array.splice(index, 1));\n      index = array.indexOf(val);\n    }\n    return results;\n  })\n    .reduce((returnArray, subArray) => returnArray.concat(subArray), [])\n    .reduce((returnArray, val) => {\n      if (returnArray.indexOf(val) !== -1) {\n        return returnArray;\n      }\n      return returnArray.concat(val instanceof Array ? [val] : val);\n    }, []);\n}\n\nfunction without(values, array) {\n  const newArray = array.slice();\n  pull(values, newArray);\n  return newArray;\n}\n\nfunction peek(arr) {\n  if (!arr || !(arr instanceof Array)) {\n    return null;\n  }\n  return arr[arr.length - 1] || null;\n}\n\nfunction noop() { }\n\nfunction isList(listish) {\n  return listish === null || (isObject(listish) && typeof listish.next === 'object');\n}\n\nfunction assertList(list) {\n  if (!isList(list)) {\n    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\n  }\n}\n\nfunction listForEach(iterator, list) {\n  assertList(list);\n  let next = list;\n  let i = 0;\n  while (next) {\n    iterator(next, i);\n    next = next.next;\n    i = i + 1;\n  }\n}\n\nfunction listMap(iterator, list) {\n  const newNodes = [];\n  listForEach((node, index) => {\n    newNodes.push(iterator(node, index));\n  }, list);\n  return newNodes.reduceRight((tail, node) => assign({}, node, {\n    next: tail\n  }), null);\n}\n\nfunction listReduce(reducer, accumulator, list) {\n  return (function foldl(f, a, head, i) {\n    if (head === null) {\n      return a;\n    }\n    assertList(head);\n    return foldl(f, f(a, head, i), head.next, i + 1);\n  }(reducer, accumulator, list, 0));\n}\n\nfunction batchAsyncActions(fns, callback) {\n  if (!isArray(fns)) {\n    throw new TypeError(\n      'batchAsyncResults() expects an array of functions as the first parameter.'\n    );\n  }\n  let resolvedCount = 0;\n  const results = [];\n  fns.forEach((fn) => {\n    fn((result) => {\n      resolvedCount += 1;\n      results.push(result);\n      if (resolvedCount === fns.length) {\n        callback(results);\n      }\n    });\n  });\n}\n\nexport {\n  emptyObject,\n  isArray,\n  isObject,\n  isFunction,\n  isString,\n  isList,\n  listForEach,\n  listMap,\n  listReduce,\n  batchAsyncActions,\n  noop,\n  keys,\n  peek,\n  cloneDeep,\n  assign,\n  arrayHead,\n  pull,\n  without\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js"],"sourceRoot":""}