{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///marbles.min.js","webpack:///webpack/bootstrap 4431ed9c86cb42117359","webpack:///./src/marbles.js","webpack:///./src/util.js","webpack:///./~/deep-equal/index.js","webpack:///./~/deep-equal/lib/is_arguments.js","webpack:///./~/deep-equal/lib/keys.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_util","util","Marbles","routingGraph","expandSegment","segment","data","replace","DYNAMIC_SEGMENT_REGEX","segmentKey","extractSegmentData","templateSegment","segmentWithData","dynamicSegments","match","RegExp","source","DIGIT_SEGMENT_REGEX","reduce","index","assign","emptyObject","segmentToRegex","regexed","findListNode","nodeId","list","next","chainData","upToNode","stop","isObject","graphNodeToListNode","graph","graphNode","deactivateGraphNode","force","immutableGraph","recDeactivate","target","current","g","curr","dependency","active","children","forEach","childId","cloneDeep","activateGraphNode","dfsActivate","searchId","currentId","dependencyMet","search","depMet","parents","keys","filter","indexOf","activated","parentId","retG","appendNode","node","head","clonedHead","last","parseHash","hashRoute","routeGraph","recParse","hash","rootId","visitedNodes","child","newG","matches","substrIndex","length","arrayHead","substr","newGraph","buildGraph","IMMUTABLE_GRAPH","listToHashRoute","listReduce","graphToLinkedList","listHead","nextListNode","newHead","logGraph","lastGraph","peek","graphStack","JSON","stringify","push","graphToList","listDiff","from","against","includeUpdates","arr","found","equal","concat","notifyObservers","obsObj","oldGraph","oldListHead","newListHead","removed","insertedNodes","obs","listForEach","inserted","insertOrRemove","insert","segmentId","dataToUse","isString","Array","win","location","arguments","undefined","window","observers","subscribe","subscriptions","matchingKeys","sub","noop","unsubscribe","event","handler","isFunction","matchingObservers","pull","remove","getData","step","beginningState","beginningGraph","pop","newState","history","replaceState","listener","bind","start","addEventListener","removeEventListener","create","any","isArray","parse","_len","args","_key","apply","array","values","map","val","results","splice","returnArray","subArray","without","newArray","slice","isList","listish","assertList","i","listMap","newNodes","reduceRight","tail","reducer","accumulator","foldl","f","a","batchAsyncActions","fns","callback","resolvedCount","fn","result","deepEqual","isUndefinedOrNull","isBuffer","x","copy","objEquiv","b","opts","isArguments","pSlice","ka","objectKeys","kb","e","sort","actual","expected","Date","getTime","strict","supported","object","toString","unsupported","propertyIsEnumerable","supportsArgumentsClass","shim"],"mappings":"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","file":"marbles.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"marbles\"] = factory();\n\telse\n\t\troot[\"marbles\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\tvar util = _interopRequireWildcard(_util);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Marbles = function Marbles(routingGraph) {\n\t  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\t\n\t  _classCallCheck(this, Marbles);\n\t\n\t  var IMMUTABLE_GRAPH = routingGraph;\n\t  var DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n\t  var DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n\t  var observers = util.keys(IMMUTABLE_GRAPH).reduce(function (obj, key) {\n\t    obj[key] = [];\n\t    return obj;\n\t  }, util.emptyObject());\n\t  var graphStack = [];\n\t\n\t  // Private methods\n\t  function expandSegment(segment, data) {\n\t    return segment.replace(DYNAMIC_SEGMENT_REGEX, function (segmentKey) {\n\t      return data[segmentKey.replace(':', '')];\n\t    });\n\t  }\n\t\n\t  function extractSegmentData(templateSegment, segmentWithData) {\n\t    var dynamicSegments = templateSegment.match(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')) || [];\n\t    return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce(function (data, value, index) {\n\t      data[dynamicSegments[index].replace(':', '')] = value;\n\t      return util.assign(util.emptyObject(), data);\n\t    }, util.emptyObject());\n\t  }\n\t\n\t  function segmentToRegex(segment) {\n\t    // It just got weird\n\t    var regexed = segment.replace(new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'), DIGIT_SEGMENT_REGEX.source);\n\t    return new RegExp(regexed);\n\t  }\n\t\n\t  function findListNode(nodeId, list) {\n\t    var next = list;\n\t    while (next) {\n\t      if (next.id === nodeId) {\n\t        return next;\n\t      }\n\t      next = next.next;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function chainData(list, upToNode) {\n\t    var data = util.emptyObject();\n\t    var stop = util.isObject(upToNode) ? upToNode : { data: {} };\n\t    var next = list;\n\t    while (next && next !== stop) {\n\t      util.assign(data, next.data);\n\t      next = next.next;\n\t    }\n\t    return util.assign(data, stop.data);\n\t  }\n\t\n\t  function graphNodeToListNode(id, graph) {\n\t    var graphNode = graph[id];\n\t    return util.assign(util.emptyObject(), graphNode, {\n\t      id: id,\n\t      segment: expandSegment(graphNode.segment, graphNode.data),\n\t      next: null\n\t    });\n\t  }\n\t\n\t  function deactivateGraphNode(force, nodeId, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    function recDeactivate(target, current, g) {\n\t      var curr = g[current];\n\t      if (target === current || curr.dependency === target || force) {\n\t        curr.active = false;\n\t        curr.data = util.emptyObject();\n\t      }\n\t      curr.children.forEach(function (childId) {\n\t        return recDeactivate(target, childId, g);\n\t      });\n\t    }\n\t    recDeactivate(nodeId, nodeId, graph);\n\t    return graph;\n\t  }\n\t\n\t  function activateGraphNode(nodeId, data, immutableGraph) {\n\t    var graph = util.cloneDeep(immutableGraph);\n\t    var parents = util.keys(graph).filter(function (key) {\n\t      return graph[key].children.indexOf(nodeId) !== -1;\n\t    });\n\t    function dfsActivate(searchId, currentId, dependencyMet) {\n\t      var curr = graph[currentId];\n\t      var search = graph[searchId];\n\t      if (currentId === searchId && dependencyMet) {\n\t        search.active = true;\n\t        search.data = data;\n\t        return true;\n\t      } else if (currentId === searchId && !dependencyMet) {\n\t        return false;\n\t      }\n\t      return curr.children.reduce(function (depMet, childId) {\n\t        return dfsActivate(searchId, childId, depMet);\n\t      }, dependencyMet || currentId === search.dependency);\n\t    }\n\t\n\t    var activated = dfsActivate(nodeId, 'root', false);\n\t    if (activated) {\n\t      // deactivate immediate siblings\n\t      return parents.reduce(function (g, parentId) {\n\t        return g[parentId].children.filter(function (id) {\n\t          return id !== nodeId;\n\t        }).reduce(function (retG, childId) {\n\t          return deactivateGraphNode(true, childId, retG);\n\t        }, g);\n\t      }, graph);\n\t    }\n\t    return graph;\n\t  }\n\t\n\t  function appendNode(node, head) {\n\t    var clonedHead = util.cloneDeep(head);\n\t    var next = clonedHead;\n\t    var last = void 0;\n\t    var dependencyMet = false;\n\t    while (next) {\n\t      dependencyMet = dependencyMet || next.id === node.dependency;\n\t      last = next;\n\t      next = next.next;\n\t    }\n\t    if (dependencyMet) {\n\t      last.next = util.cloneDeep(node);\n\t    }\n\t    return clonedHead;\n\t  }\n\t\n\t  function parseHash(hashRoute, routeGraph) {\n\t    function recParse(hash, rootId, visitedNodes, graph) {\n\t      var root = graph[rootId];\n\t      return root.children.reduce(function (g, childId) {\n\t        var child = graph[childId];\n\t        var newG = g;\n\t        var matches = hash.match(segmentToRegex(child.segment)) || [];\n\t        var substrIndex = matches.index ? matches.index + matches[0].length : 0;\n\t        if (visitedNodes[childId]) {\n\t          return newG;\n\t        }\n\t        visitedNodes[childId] = true;\n\t        if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\n\t          newG = activateGraphNode(childId, extractSegmentData(child.segment, util.arrayHead(matches)), graph);\n\t        }\n\t        return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n\t      }, graph);\n\t    }\n\t    var newGraph = util.cloneDeep(routeGraph);\n\t    return recParse(hashRoute, 'root', {}, newGraph);\n\t  }\n\t\n\t  function buildGraph(hash) {\n\t    return parseHash(hash, IMMUTABLE_GRAPH);\n\t  }\n\t\n\t  function listToHashRoute(head) {\n\t    return util.listReduce(function (hash, node) {\n\t      if (node.segment) {\n\t        return '' + hash + node.segment + '/';\n\t      }\n\t      return hash;\n\t    }, '#', head);\n\t  }\n\t\n\t  function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n\t    var root = graph[rootId];\n\t    var nextListNode = graphNodeToListNode(rootId, graph);\n\t    var newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\n\t\n\t    return root.children.reduce(function (head, childId) {\n\t      if (visitedNodes[childId]) {\n\t        return head;\n\t      }\n\t      visitedNodes[childId] = true;\n\t      return graphToLinkedList(graph, childId, head, visitedNodes);\n\t    }, newHead);\n\t  }\n\t\n\t  function logGraph(newGraph) {\n\t    var lastGraph = util.peek(graphStack);\n\t    if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n\t      graphStack.push(newGraph);\n\t    }\n\t    return newGraph;\n\t  }\n\t\n\t  function graphToList(graph) {\n\t    if (!graph) {\n\t      return null;\n\t    }\n\t    return graphToLinkedList(graph, 'root', graphNodeToListNode('root', graph), util.emptyObject());\n\t  }\n\t\n\t  function listDiff(from, against, includeUpdates) {\n\t    return util.listReduce(function (arr, node) {\n\t      var found = findListNode(node.id, against);\n\t      if (!found || includeUpdates && !util.equal(found.data, node.data)) {\n\t        return arr.concat(node);\n\t      }\n\t      return arr;\n\t    }, [], from);\n\t  }\n\t\n\t  function notifyObservers(obsObj, oldGraph, newGraph) {\n\t    var oldListHead = graphToList(oldGraph);\n\t    var newListHead = graphToList(newGraph);\n\t    var removed = listDiff(oldListHead, newListHead, false);\n\t    var insertedNodes = listDiff(newListHead, oldListHead, true);\n\t    removed.forEach(function (node) {\n\t      obsObj[node.id].forEach(function (obs) {\n\t        obs.removed(chainData(oldListHead, node));\n\t      });\n\t    });\n\t    util.listForEach(function (node) {\n\t      obsObj[node.id].forEach(function (obs) {\n\t        obs.inserted(chainData(newListHead, node));\n\t      });\n\t    }, insertedNodes[0] || null);\n\t  }\n\t\n\t  function insertOrRemove(insert, segmentId, data) {\n\t    var dataToUse = data;\n\t    if (!util.isString(segmentId) || !IMMUTABLE_GRAPH[segmentId]) {\n\t      return null;\n\t    }\n\t    if (data === null || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data instanceof Array) {\n\t      dataToUse = util.emptyObject();\n\t    }\n\t    var graph = buildGraph(win.location.hash);\n\t    var newGraph = void 0;\n\t    if (insert) {\n\t      newGraph = activateGraphNode(segmentId, dataToUse, graph);\n\t    } else {\n\t      newGraph = deactivateGraphNode(false, segmentId, graph);\n\t    }\n\t    win.location.hash = listToHashRoute(graphToList(newGraph));\n\t    return this;\n\t  }\n\t  // End private methods\n\t\n\t  // Public methods\n\t  this.subscribe = function subscribe(subscriptions) {\n\t    if (!util.isObject(subscriptions)) {\n\t      return false;\n\t    }\n\t    var matchingKeys = util.keys(subscriptions).filter(function (key) {\n\t      return !!observers[key];\n\t    });\n\t    if (matchingKeys.length === 0) {\n\t      return false;\n\t    }\n\t    matchingKeys.forEach(function (key) {\n\t      var sub = subscriptions[key];\n\t      observers[key].push({\n\t        inserted: sub.inserted || util.noop,\n\t        removed: sub.removed || util.noop\n\t      });\n\t    });\n\t    return true;\n\t  };\n\t  this.unsubscribe = function unsubscribe(segmentId, event, handler) {\n\t    if (!util.isString(segmentId) || !util.isString(event) || !util.isFunction(handler) || !observers[segmentId]) {\n\t      return false;\n\t    }\n\t    var matchingObservers = observers[segmentId].filter(function (obs) {\n\t      return obs[event] === handler;\n\t    });\n\t    return util.pull(matchingObservers, observers[segmentId]);\n\t  };\n\t  this.insert = function insert(segmentId, data) {\n\t    return insertOrRemove.call(this, true, segmentId, data);\n\t  };\n\t  this.remove = function remove(segmentId) {\n\t    return insertOrRemove.call(this, false, segmentId);\n\t  };\n\t  this.getData = function getData() {\n\t    return chainData(graphToList(buildGraph(win.location.hash)));\n\t  };\n\t  this.step = function step() {\n\t    var beginningState = win.location.hash;\n\t    var beginningGraph = buildGraph(beginningState);\n\t    notifyObservers(observers, graphStack.pop(), beginningGraph);\n\t    logGraph(beginningGraph);\n\t    var newState = win.location.hash;\n\t    var newGraph = buildGraph(newState);\n\t    win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(newGraph)));\n\t    return this;\n\t  };\n\t\n\t  var listener = this.step.bind(this);\n\t  this.start = function start() {\n\t    win.addEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  this.stop = function stop() {\n\t    win.removeEventListener('hashchange', listener);\n\t    return this;\n\t  };\n\t  // End public methods\n\t};\n\t\n\texports.default = Marbles;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar deepEqual = __webpack_require__(2);\n\t\n\tfunction emptyObject() {\n\t  return Object.create(null);\n\t}\n\t\n\tfunction isObject(any) {\n\t  return (typeof any === 'undefined' ? 'undefined' : _typeof(any)) === 'object' && any !== null && !(any instanceof Array);\n\t}\n\t\n\tfunction isArray(any) {\n\t  return any instanceof Array;\n\t}\n\t\n\tfunction isString(any) {\n\t  return typeof any === 'string';\n\t}\n\t\n\tfunction isFunction(any) {\n\t  return typeof any === 'function';\n\t}\n\t\n\tfunction keys(obj) {\n\t  return Object.keys(obj);\n\t}\n\t\n\tfunction cloneDeep(obj) {\n\t  return JSON.parse(JSON.stringify(obj));\n\t}\n\t\n\tfunction assign() {\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  return Object.assign.apply(this, args);\n\t}\n\t\n\tfunction arrayHead(array) {\n\t  if (typeof array === 'undefined' || !(array instanceof Array)) {\n\t    return undefined;\n\t  }\n\t  return array[0];\n\t}\n\t\n\tfunction pull(values, array) {\n\t  return values.map(function (val) {\n\t    var index = array.indexOf(val);\n\t    var results = [];\n\t    while (index !== -1) {\n\t      results = results.concat(array.splice(index, 1));\n\t      index = array.indexOf(val);\n\t    }\n\t    return results;\n\t  }).reduce(function (returnArray, subArray) {\n\t    return returnArray.concat(subArray);\n\t  }, []).reduce(function (returnArray, val) {\n\t    if (returnArray.indexOf(val) !== -1) {\n\t      return returnArray;\n\t    }\n\t    return returnArray.concat(val instanceof Array ? [val] : val);\n\t  }, []);\n\t}\n\t\n\tfunction without(values, array) {\n\t  var newArray = array.slice();\n\t  pull(values, newArray);\n\t  return newArray;\n\t}\n\t\n\tfunction peek(arr) {\n\t  if (!arr || !(arr instanceof Array)) {\n\t    return null;\n\t  }\n\t  return arr[arr.length - 1] || null;\n\t}\n\t\n\tfunction noop() {}\n\t\n\tfunction isList(listish) {\n\t  return listish === null || isObject(listish) && _typeof(listish.next) === 'object';\n\t}\n\t\n\tfunction assertList(list) {\n\t  if (!isList(list)) {\n\t    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\n\t  }\n\t}\n\t\n\tfunction listForEach(iterator, list) {\n\t  assertList(list);\n\t  var next = list;\n\t  var i = 0;\n\t  while (next) {\n\t    iterator(next, i);\n\t    next = next.next;\n\t    i = i + 1;\n\t  }\n\t}\n\t\n\tfunction listMap(iterator, list) {\n\t  var newNodes = [];\n\t  listForEach(function (node, index) {\n\t    newNodes.push(iterator(node, index));\n\t  }, list);\n\t  return newNodes.reduceRight(function (tail, node) {\n\t    return assign({}, node, {\n\t      next: tail\n\t    });\n\t  }, null);\n\t}\n\t\n\tfunction listReduce(reducer, accumulator, list) {\n\t  return function foldl(f, a, head, i) {\n\t    if (head === null) {\n\t      return a;\n\t    }\n\t    assertList(head);\n\t    return foldl(f, f(a, head, i), head.next, i + 1);\n\t  }(reducer, accumulator, list, 0);\n\t}\n\t\n\tfunction batchAsyncActions(fns, callback) {\n\t  if (!isArray(fns)) {\n\t    throw new TypeError('batchAsyncResults() expects an array of functions as the first parameter.');\n\t  }\n\t  var resolvedCount = 0;\n\t  var results = [];\n\t  fns.forEach(function (fn) {\n\t    fn(function (result) {\n\t      resolvedCount += 1;\n\t      results.push(result);\n\t      if (resolvedCount === fns.length) {\n\t        callback(results);\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\texports.equal = deepEqual;\n\texports.emptyObject = emptyObject;\n\texports.isArray = isArray;\n\texports.isObject = isObject;\n\texports.isFunction = isFunction;\n\texports.isString = isString;\n\texports.isList = isList;\n\texports.listForEach = listForEach;\n\texports.listMap = listMap;\n\texports.listReduce = listReduce;\n\texports.batchAsyncActions = batchAsyncActions;\n\texports.noop = noop;\n\texports.keys = keys;\n\texports.peek = peek;\n\texports.cloneDeep = cloneDeep;\n\texports.assign = assign;\n\texports.arrayHead = arrayHead;\n\texports.pull = pull;\n\texports.without = without;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pSlice = Array.prototype.slice;\n\tvar objectKeys = __webpack_require__(4);\n\tvar isArguments = __webpack_require__(3);\n\t\n\tvar deepEqual = module.exports = function (actual, expected, opts) {\n\t  if (!opts) opts = {};\n\t  // 7.1. All identical values are equivalent, as determined by ===.\n\t  if (actual === expected) {\n\t    return true;\n\t\n\t  } else if (actual instanceof Date && expected instanceof Date) {\n\t    return actual.getTime() === expected.getTime();\n\t\n\t  // 7.3. Other pairs that do not both pass typeof value == 'object',\n\t  // equivalence is determined by ==.\n\t  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n\t    return opts.strict ? actual === expected : actual == expected;\n\t\n\t  // 7.4. For all other Object pairs, including Array objects, equivalence is\n\t  // determined by having the same number of owned properties (as verified\n\t  // with Object.prototype.hasOwnProperty.call), the same set of keys\n\t  // (although not necessarily the same order), equivalent values for every\n\t  // corresponding key, and an identical 'prototype' property. Note: this\n\t  // accounts for both named and indexed properties on Arrays.\n\t  } else {\n\t    return objEquiv(actual, expected, opts);\n\t  }\n\t}\n\t\n\tfunction isUndefinedOrNull(value) {\n\t  return value === null || value === undefined;\n\t}\n\t\n\tfunction isBuffer (x) {\n\t  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n\t  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n\t    return false;\n\t  }\n\t  if (x.length > 0 && typeof x[0] !== 'number') return false;\n\t  return true;\n\t}\n\t\n\tfunction objEquiv(a, b, opts) {\n\t  var i, key;\n\t  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n\t    return false;\n\t  // an identical 'prototype' property.\n\t  if (a.prototype !== b.prototype) return false;\n\t  //~~~I've managed to break Object.keys through screwy arguments passing.\n\t  //   Converting to array solves the problem.\n\t  if (isArguments(a)) {\n\t    if (!isArguments(b)) {\n\t      return false;\n\t    }\n\t    a = pSlice.call(a);\n\t    b = pSlice.call(b);\n\t    return deepEqual(a, b, opts);\n\t  }\n\t  if (isBuffer(a)) {\n\t    if (!isBuffer(b)) {\n\t      return false;\n\t    }\n\t    if (a.length !== b.length) return false;\n\t    for (i = 0; i < a.length; i++) {\n\t      if (a[i] !== b[i]) return false;\n\t    }\n\t    return true;\n\t  }\n\t  try {\n\t    var ka = objectKeys(a),\n\t        kb = objectKeys(b);\n\t  } catch (e) {//happens when one is a string literal and the other isn't\n\t    return false;\n\t  }\n\t  // having the same number of owned properties (keys incorporates\n\t  // hasOwnProperty)\n\t  if (ka.length != kb.length)\n\t    return false;\n\t  //the same set of keys (although not necessarily the same order),\n\t  ka.sort();\n\t  kb.sort();\n\t  //~~~cheap key test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    if (ka[i] != kb[i])\n\t      return false;\n\t  }\n\t  //equivalent values for every corresponding key, and\n\t  //~~~possibly expensive deep test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    key = ka[i];\n\t    if (!deepEqual(a[key], b[key], opts)) return false;\n\t  }\n\t  return typeof a === typeof b;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar supportsArgumentsClass = (function(){\n\t  return Object.prototype.toString.call(arguments)\n\t})() == '[object Arguments]';\n\t\n\texports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\t\n\texports.supported = supported;\n\tfunction supported(object) {\n\t  return Object.prototype.toString.call(object) == '[object Arguments]';\n\t};\n\t\n\texports.unsupported = unsupported;\n\tfunction unsupported(object){\n\t  return object &&\n\t    typeof object == 'object' &&\n\t    typeof object.length == 'number' &&\n\t    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n\t    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n\t    false;\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\texports = module.exports = typeof Object.keys === 'function'\n\t  ? Object.keys : shim;\n\t\n\texports.shim = shim;\n\tfunction shim (obj) {\n\t  var keys = [];\n\t  for (var key in obj) keys.push(key);\n\t  return keys;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// marbles.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4431ed9c86cb42117359","import * as util from './util.js';\n\nexport default class Marbles {\n  constructor(routingGraph, win = window) {\n    const IMMUTABLE_GRAPH = routingGraph;\n    const DYNAMIC_SEGMENT_REGEX = /:[a-zA-Z]+(?=\\/?)/;\n    const DIGIT_SEGMENT_REGEX = /\\d+(?=\\/?)/;\n    const observers = util.keys(IMMUTABLE_GRAPH).reduce((obj, key) => {\n      obj[key] = [];\n      return obj;\n    }, util.emptyObject());\n    const graphStack = [];\n\n    // Private methods\n    function expandSegment(segment, data) {\n      return segment.replace(\n        DYNAMIC_SEGMENT_REGEX,\n        segmentKey => data[segmentKey.replace(':', '')]\n      );\n    }\n\n    function extractSegmentData(templateSegment, segmentWithData) {\n      const dynamicSegments = templateSegment.match(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g')\n      ) || [];\n      return (segmentWithData.match(DIGIT_SEGMENT_REGEX) || []).reduce((data, value, index) => {\n        data[dynamicSegments[index].replace(':', '')] = value;\n        return util.assign(util.emptyObject(), data);\n      },\n        util.emptyObject()\n      );\n    }\n\n    function segmentToRegex(segment) {\n      // It just got weird\n      const regexed = segment.replace(\n        new RegExp(DYNAMIC_SEGMENT_REGEX.source, 'g'),\n        DIGIT_SEGMENT_REGEX.source\n      );\n      return new RegExp(regexed);\n    }\n\n    function findListNode(nodeId, list) {\n      let next = list;\n      while (next) {\n        if (next.id === nodeId) {\n          return next;\n        }\n        next = next.next;\n      }\n      return null;\n    }\n\n    function chainData(list, upToNode) {\n      const data = util.emptyObject();\n      const stop = util.isObject(upToNode) ? upToNode : { data: {} };\n      let next = list;\n      while (next && next !== stop) {\n        util.assign(data, next.data);\n        next = next.next;\n      }\n      return util.assign(data, stop.data);\n    }\n\n    function graphNodeToListNode(id, graph) {\n      const graphNode = graph[id];\n      return util.assign(util.emptyObject(), graphNode, {\n        id,\n        segment: expandSegment(graphNode.segment, graphNode.data),\n        next: null,\n      });\n    }\n\n    function deactivateGraphNode(force, nodeId, immutableGraph) {\n      const graph = util.cloneDeep(immutableGraph);\n      function recDeactivate(target, current, g) {\n        const curr = g[current];\n        if (target === current || curr.dependency === target || force) {\n          curr.active = false;\n          curr.data = util.emptyObject();\n        }\n        curr.children.forEach(childId => recDeactivate(target, childId, g));\n      }\n      recDeactivate(nodeId, nodeId, graph);\n      return graph;\n    }\n\n    function activateGraphNode(nodeId, data, immutableGraph) {\n      const graph = util.cloneDeep(immutableGraph);\n      const parents = util.keys(graph).filter(key => graph[key].children.indexOf(nodeId) !== -1);\n      function dfsActivate(searchId, currentId, dependencyMet) {\n        const curr = graph[currentId];\n        const search = graph[searchId];\n        if (currentId === searchId && dependencyMet) {\n          search.active = true;\n          search.data = data;\n          return true;\n        }\n        else if (currentId === searchId && !dependencyMet) {\n          return false;\n        }\n        return curr.children.reduce(\n          (depMet, childId) => dfsActivate(searchId, childId, depMet),\n          dependencyMet || currentId === search.dependency\n        );\n      }\n\n      const activated = dfsActivate(nodeId, 'root', false);\n      if (activated) {\n        // deactivate immediate siblings\n        return parents.reduce((g, parentId) =>\n          g[parentId].children.filter(id => id !== nodeId).reduce((retG, childId) =>\n            deactivateGraphNode(true, childId, retG),\n            g),\n          graph);\n      }\n      return graph;\n    }\n\n    function appendNode(node, head) {\n      const clonedHead = util.cloneDeep(head);\n      let next = clonedHead;\n      let last;\n      let dependencyMet = false;\n      while (next) {\n        dependencyMet = dependencyMet || next.id === node.dependency;\n        last = next;\n        next = next.next;\n      }\n      if (dependencyMet) {\n        last.next = util.cloneDeep(node);\n      }\n      return clonedHead;\n    }\n\n    function parseHash(hashRoute, routeGraph) {\n      function recParse(hash, rootId, visitedNodes, graph) {\n        const root = graph[rootId];\n        return root.children.reduce((g, childId) => {\n          const child = graph[childId];\n          let newG = g;\n          const matches = hash.match(segmentToRegex(child.segment)) || [];\n          const substrIndex = matches.index ? matches.index + matches[0].length : 0;\n          if (visitedNodes[childId]) {\n            return newG;\n          }\n          visitedNodes[childId] = true;\n          if (matches.length > 0 && (graph[child.dependency] || util.emptyObject()).active) {\n            newG = activateGraphNode(\n              childId,\n              extractSegmentData(child.segment, util.arrayHead(matches)),\n              graph\n            );\n          }\n          return recParse(hash.substr(substrIndex), childId, visitedNodes, newG);\n        }, graph);\n      }\n      const newGraph = util.cloneDeep(routeGraph);\n      return recParse(hashRoute, 'root', {}, newGraph);\n    }\n\n    function buildGraph(hash) {\n      return parseHash(hash, IMMUTABLE_GRAPH);\n    }\n\n    function listToHashRoute(head) {\n      return util.listReduce((hash, node) => {\n        if (node.segment) {\n          return `${hash}${node.segment}/`;\n        }\n        return hash;\n      }, '#', head);\n    }\n\n    function graphToLinkedList(graph, rootId, listHead, visitedNodes) {\n      const root = graph[rootId];\n      const nextListNode = graphNodeToListNode(rootId, graph);\n      const newHead = root.active ? appendNode(nextListNode, listHead) : util.cloneDeep(listHead);\n\n      return root.children.reduce(\n        (head, childId) => {\n          if (visitedNodes[childId]) {\n            return head;\n          }\n          visitedNodes[childId] = true;\n          return graphToLinkedList(graph, childId, head, visitedNodes);\n        },\n        newHead\n      );\n    }\n\n    function logGraph(newGraph) {\n      const lastGraph = util.peek(graphStack);\n      if (!lastGraph || JSON.stringify(lastGraph) !== JSON.stringify(newGraph)) {\n        graphStack.push(newGraph);\n      }\n      return newGraph;\n    }\n\n    function graphToList(graph) {\n      if (!graph) {\n        return null;\n      }\n      return graphToLinkedList(\n        graph,\n        'root',\n        graphNodeToListNode('root', graph),\n        util.emptyObject()\n      );\n    }\n\n    function listDiff(from, against, includeUpdates) {\n      return util.listReduce((arr, node) => {\n        const found = findListNode(node.id, against);\n        if (!found || (includeUpdates && !util.equal(found.data, node.data))) {\n          return arr.concat(node);\n        }\n        return arr;\n      }, [], from);\n    }\n\n    function notifyObservers(obsObj, oldGraph, newGraph) {\n      const oldListHead = graphToList(oldGraph);\n      const newListHead = graphToList(newGraph);\n      const removed = listDiff(oldListHead, newListHead, false);\n      const insertedNodes = listDiff(newListHead, oldListHead, true);\n      removed.forEach((node) => {\n        obsObj[node.id].forEach((obs) => {\n          obs.removed(chainData(oldListHead, node));\n        });\n      });\n      util.listForEach((node) => {\n        obsObj[node.id].forEach((obs) => {\n          obs.inserted(chainData(newListHead, node));\n        });\n      }, insertedNodes[0] || null);\n    }\n\n    function insertOrRemove(insert, segmentId, data) {\n      let dataToUse = data;\n      if (!util.isString(segmentId) || !IMMUTABLE_GRAPH[segmentId]) {\n        return null;\n      }\n      if (data === null || typeof data !== 'object' || data instanceof Array) {\n        dataToUse = util.emptyObject();\n      }\n      const graph = buildGraph(win.location.hash);\n      let newGraph;\n      if (insert) {\n        newGraph = activateGraphNode(segmentId, dataToUse, graph);\n      }\n      else {\n        newGraph = deactivateGraphNode(false, segmentId, graph);\n      }\n      win.location.hash = listToHashRoute(graphToList(newGraph));\n      return this;\n    }\n    // End private methods\n\n    // Public methods\n    this.subscribe = function subscribe(subscriptions) {\n      if (!util.isObject(subscriptions)) {\n        return false;\n      }\n      const matchingKeys = util.keys(subscriptions).filter(key => !!observers[key]);\n      if (matchingKeys.length === 0) {\n        return false;\n      }\n      matchingKeys.forEach(key => {\n        const sub = subscriptions[key];\n        observers[key].push({\n          inserted: sub.inserted || util.noop,\n          removed: sub.removed || util.noop,\n        });\n      });\n      return true;\n    };\n    this.unsubscribe = function unsubscribe(segmentId, event, handler) {\n      if (\n        !util.isString(segmentId) ||\n        !util.isString(event) ||\n        !util.isFunction(handler) ||\n        !observers[segmentId]\n      ) {\n        return false;\n      }\n      const matchingObservers = observers[segmentId].filter((obs) => obs[event] === handler);\n      return util.pull(matchingObservers, observers[segmentId]);\n    };\n    this.insert = function insert(segmentId, data) {\n      return insertOrRemove.call(this, true, segmentId, data);\n    };\n    this.remove = function remove(segmentId) {\n      return insertOrRemove.call(this, false, segmentId);\n    };\n    this.getData = function getData() {\n      return chainData(graphToList(buildGraph(win.location.hash)));\n    };\n    this.step = function step() {\n      const beginningState = win.location.hash;\n      const beginningGraph = buildGraph(beginningState);\n      notifyObservers(observers, graphStack.pop(), beginningGraph);\n      logGraph(beginningGraph);\n      const newState = win.location.hash;\n      const newGraph = buildGraph(newState);\n      win.history.replaceState(util.emptyObject(), '', listToHashRoute(graphToList(newGraph)));\n      return this;\n    };\n\n    const listener = this.step.bind(this);\n    this.start = function start() {\n      win.addEventListener('hashchange', listener);\n      return this;\n    };\n    this.stop = function stop() {\n      win.removeEventListener('hashchange', listener);\n      return this;\n    };\n    // End public methods\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/marbles.js","const deepEqual = require('deep-equal');\n\nfunction emptyObject() {\n  return Object.create(null);\n}\n\nfunction isObject(any) {\n  return typeof any === 'object' && any !== null && !(any instanceof Array);\n}\n\nfunction isArray(any) {\n  return any instanceof Array;\n}\n\nfunction isString(any) {\n  return typeof any === 'string';\n}\n\nfunction isFunction(any) {\n  return typeof any === 'function';\n}\n\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n\nfunction cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction assign(...args) {\n  return Object.assign.apply(this, args);\n}\n\nfunction arrayHead(array) {\n  if (typeof array === 'undefined' || !(array instanceof Array)) {\n    return undefined;\n  }\n  return array[0];\n}\n\nfunction pull(values, array) {\n  return values.map((val) => {\n    let index = array.indexOf(val);\n    let results = [];\n    while (index !== -1) {\n      results = results.concat(array.splice(index, 1));\n      index = array.indexOf(val);\n    }\n    return results;\n  })\n    .reduce((returnArray, subArray) => returnArray.concat(subArray), [])\n    .reduce((returnArray, val) => {\n      if (returnArray.indexOf(val) !== -1) {\n        return returnArray;\n      }\n      return returnArray.concat(val instanceof Array ? [val] : val);\n    }, []);\n}\n\nfunction without(values, array) {\n  const newArray = array.slice();\n  pull(values, newArray);\n  return newArray;\n}\n\nfunction peek(arr) {\n  if (!arr || !(arr instanceof Array)) {\n    return null;\n  }\n  return arr[arr.length - 1] || null;\n}\n\nfunction noop() { }\n\nfunction isList(listish) {\n  return listish === null || (isObject(listish) && typeof listish.next === 'object');\n}\n\nfunction assertList(list) {\n  if (!isList(list)) {\n    throw new TypeError('listForEach requires a list! Lists are objects with a `next` property.');\n  }\n}\n\nfunction listForEach(iterator, list) {\n  assertList(list);\n  let next = list;\n  let i = 0;\n  while (next) {\n    iterator(next, i);\n    next = next.next;\n    i = i + 1;\n  }\n}\n\nfunction listMap(iterator, list) {\n  const newNodes = [];\n  listForEach((node, index) => {\n    newNodes.push(iterator(node, index));\n  }, list);\n  return newNodes.reduceRight((tail, node) => assign({}, node, {\n    next: tail\n  }), null);\n}\n\nfunction listReduce(reducer, accumulator, list) {\n  return (function foldl(f, a, head, i) {\n    if (head === null) {\n      return a;\n    }\n    assertList(head);\n    return foldl(f, f(a, head, i), head.next, i + 1);\n  }(reducer, accumulator, list, 0));\n}\n\nfunction batchAsyncActions(fns, callback) {\n  if (!isArray(fns)) {\n    throw new TypeError(\n      'batchAsyncResults() expects an array of functions as the first parameter.'\n    );\n  }\n  let resolvedCount = 0;\n  const results = [];\n  fns.forEach((fn) => {\n    fn((result) => {\n      resolvedCount += 1;\n      results.push(result);\n      if (resolvedCount === fns.length) {\n        callback(results);\n      }\n    });\n  });\n}\n\nexport {\n  deepEqual as equal,\n  emptyObject,\n  isArray,\n  isObject,\n  isFunction,\n  isString,\n  isList,\n  listForEach,\n  listMap,\n  listReduce,\n  batchAsyncActions,\n  noop,\n  keys,\n  peek,\n  cloneDeep,\n  assign,\n  arrayHead,\n  pull,\n  without\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/index.js\n// module id = 2\n// module chunks = 0","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/is_arguments.js\n// module id = 3\n// module chunks = 0","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-equal/lib/keys.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}